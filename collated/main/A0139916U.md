# A0139916U
###### \java\seedu\savvytasker\commons\events\model\AliasSymbolChangedEvent.java
``` java
package seedu.savvytasker.commons.events.model;

import seedu.savvytasker.commons.events.BaseEvent;
import seedu.savvytasker.model.alias.AliasSymbol;

/**
 * Represents an event where the user has added an alias symbol.
 */
public class AliasSymbolChangedEvent extends BaseEvent {
    /**
     * The action that was performed, i.e. the symbol was added or removed.
     */
    public enum Action {
        Added,
        Removed;
    }
    
    public final AliasSymbol symbol;
    public final Action action;
    
    public AliasSymbolChangedEvent(AliasSymbol symbol, Action action) {
        assert symbol != null;
        assert action != null;
        
        this.symbol = symbol;
        this.action = action;
    }
    
    @Override
    public String toString() {
        return "Alias symbol " + action.toString() + ": " + symbol.toString();
    }

}
```
###### \java\seedu\savvytasker\logic\commands\AliasCommand.java
``` java
package seedu.savvytasker.logic.commands;

import seedu.savvytasker.logic.Logic;
import seedu.savvytasker.model.alias.AliasSymbol;
import seedu.savvytasker.model.alias.DuplicateSymbolKeywordException;
import seedu.savvytasker.model.alias.SymbolKeywordNotFoundException;

/**
 * Command to create aliases
 */
public class AliasCommand extends ModelRequiringCommand {

    public static final String COMMAND_WORD = "alias";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Creates an alias for a command or parameter. "
            + "Parameters: k/KEYWORD s/SHORT_KEYWORD\n"
            + "Example: " + COMMAND_WORD
            + " k/Project Meeting s/pjm";

    public static final String MESSAGE_SUCCESS = "New alias added: %1$s";
    public static final String MESSAGE_DUPLICATE_ALIAS = "This alias is already in use";
    public static final String MESSAGE_INVALID_KEYWORD = "Unable to use a command name as a keyword!";

    private Logic logic;
    private final String keyword;
    private final String representingText;
    /**
     * Creates an alias command
     */
    public AliasCommand(String keyword, String representingText) {
        assert keyword != null;
        assert representingText != null;
        this.keyword = keyword;
        this.representingText = representingText;
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        AliasSymbol toAdd = new AliasSymbol(keyword, representingText);
        
        if (logic.canParseHeader(toAdd.getKeyword())) {
            return new CommandResult(MESSAGE_INVALID_KEYWORD);
        }
        
        try {
            model.addAliasSymbol(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (DuplicateSymbolKeywordException e) {
            return new CommandResult(MESSAGE_DUPLICATE_ALIAS);
        }
    }
    
    /**
     * Provides logic related dependencies to the alias command.
     */
    @Override
    public void setLogic(Logic logic) {
        assert logic != null;
        this.logic = logic;
    }
    
```
###### \java\seedu\savvytasker\logic\commands\AliasCommand.java
``` java
    /**
     * Checks if a command can perform undo operations
     * @return true if the command supports undo, false otherwise
     */
    @Override
    public boolean canUndo() {
        return true;
    }

    /**
     * Redo the alias command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean redo() {
        execute();
        return true;
    }
    /**
     * Undo the alias command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean undo() {
        // TODO Auto-generated method stub
        
        assert model != null;
        
        AliasSymbol toRemove = null;
        for(AliasSymbol symbol : model.getSavvyTasker().getReadOnlyListOfAliasSymbols()) {
            if (symbol.getKeyword().equals(this.keyword)) {
                toRemove = symbol;
                break;
            }
        }
        try {
            model.removeAliasSymbol(toRemove);
        } catch (SymbolKeywordNotFoundException e) {
            e.printStackTrace();
        }
        
        return true;
    }

    /**
     * Check if command is an undo command
     * @return true if the command is an undo operation, false otherwise
     */
    @Override
    public boolean isUndo() {
        return false;
    }
    
    /**
     * Check if command is a redo command
     * @return true if the command is a redo operation, false otherwise
     */
    @Override
    public boolean isRedo(){
        return false;
    }
}
```
###### \java\seedu\savvytasker\logic\commands\Command.java
``` java
    /**
     * Checks if a command can perform undo operations
     * @return true if the command supports undo, false otherwise
     */
    public abstract boolean canUndo();
    
    /**
     * Redo the command.
     * @return true if the operation completed successfully, false otherwise
     */
    public abstract boolean redo();
    
    /**
     * Undo the command
     * @return true if the operation completed successfully, false otherwise
     */
    public abstract boolean undo();
    
```
###### \java\seedu\savvytasker\logic\commands\UnaliasCommand.java
``` java
package seedu.savvytasker.logic.commands;

import seedu.savvytasker.commons.exceptions.IllegalValueException;
import seedu.savvytasker.model.alias.AliasSymbol;
import seedu.savvytasker.model.alias.DuplicateSymbolKeywordException;
import seedu.savvytasker.model.alias.SymbolKeywordNotFoundException;

/**
 * Command to remove aliases
 */
public class UnaliasCommand extends ModelRequiringCommand {

    public static final String COMMAND_WORD = "unalias";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Removes an alias for a command or parameter. "
            + "Parameters: s/SHORT_KEYWORD\n"
            + "Example: " + COMMAND_WORD
            + " s/pjm";

    public static final String MESSAGE_SUCCESS = "Alias removed: %1$s";
    public static final String MESSAGE_UNREGOGNIZED_ALIAS = "This alias is not in use";

    private final String keyword;
    private AliasSymbol toUndo;
    
    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public UnaliasCommand(String keyword) {
        this.keyword = keyword;
        this.toUndo = null;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        AliasSymbol toRemove = null;
        for(AliasSymbol symbol : model.getSavvyTasker().getReadOnlyListOfAliasSymbols()) {
            if (symbol.getKeyword().equals(this.keyword)) {
                toRemove = symbol;
                break;
            }
        }
        
        try {
            if (toRemove == null)
                return new CommandResult(MESSAGE_UNREGOGNIZED_ALIAS);
            toUndo = toRemove;
            model.removeAliasSymbol(toRemove);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toRemove));
        } catch (SymbolKeywordNotFoundException e) {
            return new CommandResult(MESSAGE_UNREGOGNIZED_ALIAS);
        }
    }
```
###### \java\seedu\savvytasker\logic\LogicManager.java
``` java
    private void registerAllDefaultCommandParsers() {
        parser.registerCommandParser(new AddCommandParser());
        parser.registerCommandParser(new DeleteCommandParser());
        parser.registerCommandParser(new FindCommandParser());
        parser.registerCommandParser(new ListCommandParser());
        parser.registerCommandParser(new ModifyCommandParser());
        parser.registerCommandParser(new HelpCommandParser());
        parser.registerCommandParser(new ClearCommandParser());
        parser.registerCommandParser(new ExitCommandParser());
        parser.registerCommandParser(new MarkCommandParser());
        parser.registerCommandParser(new UnmarkCommandParser());
        parser.registerCommandParser(new UndoCommandParser());
        parser.registerCommandParser(new RedoCommandParser());
        parser.registerCommandParser(new AliasCommandParser());
        parser.registerCommandParser(new UnaliasCommandParser());
    }
    
    private void loadAllAliasSymbols() {
        List<AliasSymbol> allSynbols = model.getSavvyTasker().getReadOnlyListOfAliasSymbols();
        for (AliasSymbol symbol : allSynbols) {
            parser.addAliasSymbol(symbol);
        }
    }
    
    private boolean undo() {
        boolean undone = false;
        
        if (!undoStack.isEmpty()) {
            Command command = undoStack.pop();
            command.undo();
            redoStack.push(command);
            undone = true;
        }
        
        return undone;
    }

    private boolean redo() {
        boolean redone = false;
        
        if (!redoStack.isEmpty()) {
            Command command = redoStack.pop();
            command.redo();
            undoStack.push(command);
            redone = true;
        }
        
        return redone;
    }
    
    @Subscribe
    public void handleAliasSymbolChangedEvent(AliasSymbolChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(
                event, "Alias symbol " + event.action.toString().toLowerCase()));
        if (event.action.equals(AliasSymbolChangedEvent.Action.Added)) {
            boolean success = parser.addAliasSymbol(event.symbol);
            if (success) {
                logger.info("Added alias symbol '"+event.symbol.getKeyword()+"' to parser");
            } else {
                logger.warning("Failed to add alias symbol '"+event.symbol.getKeyword()+" to parser");
            }
        } else {
            boolean success = parser.removeAliasSymbol(event.symbol.getKeyword());
            if (success) {
                logger.info("Removed alias symbol '"+event.symbol.getKeyword()+"' from parser");
            } else {
                logger.warning("Failed to remove alias symbol '"+event.symbol.getKeyword()+" from parser");
            }
        }
    }
    
    @Override
    public boolean canParseHeader(String header) {
        return parser.isCommandParserRegistered(header);
    }
}
```
###### \java\seedu\savvytasker\logic\parser\AddCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.AddCommand;
import seedu.savvytasker.logic.parser.DateParser.InferredDate;
import seedu.savvytasker.model.task.PriorityLevel;
import seedu.savvytasker.model.task.RecurrenceType;

public class AddCommandParser implements CommandParser<AddCommand> {
    private static final String HEADER = "add";
    private static final String READABLE_FORMAT = HEADER+" TASK_NAME [s/START_DATE] " +
            "[e/END_DATE] [l/LOCATION] [p/PRIORITY_LEVEL] [r/RECURRING_TYPE] " +
            "[n/NUMBER_OF_RECURRENCE] [c/CATEGORY] [d/DESCRIPTION]";
    
    private static final String REGEX_REF_TASK_NAME = "TaskName";
    private static final String REGEX_REF_START_DATE = "StartDate";
    private static final String REGEX_REF_END_DATE = "EndDate";
    private static final String REGEX_REF_LOCATION = "Location";
    private static final String REGEX_REF_PRIORITY_LEVEL = "Priority";
    private static final String REGEX_REF_RECURRING_TYPE = "RecurringType";
    private static final String REGEX_REF_NUMBER_OF_RECURRENCE = "RecurringNumber";
    private static final String REGEX_REF_CATEGORY = "Category";
    private static final String REGEX_REF_DESCRIPTION = "Description";
    
    private static final Pattern REGEX_PATTERN = Pattern.compile(
            HEADER+"\\s+(?<"+REGEX_REF_TASK_NAME+">([^/]+?(\\s+|$))+)((?<=\\s)(" +
            "(s/(?<"+REGEX_REF_START_DATE+">[^/]+)(?!.*\\ss/))|" +
            "(e/(?<"+REGEX_REF_END_DATE+">[^/]+)(?!.*\\se/))|" +
            "(l/(?<"+REGEX_REF_LOCATION+">[^/]+)(?!.*\\sl/))|" +
            "(p/(?<"+REGEX_REF_PRIORITY_LEVEL+">[^/]+)(?!.*\\sp/))|" +
            "(r/(?<"+REGEX_REF_RECURRING_TYPE+">[^/]+)(?!.*\\sr/))|" +
            "(n/(?<"+REGEX_REF_NUMBER_OF_RECURRENCE+">[^/]+)(?!.*\\sn/))|" +
            "(c/(?<"+REGEX_REF_CATEGORY+">[^/]+)(?!.*\\sc/))|" +
            "(d/(?<"+REGEX_REF_DESCRIPTION+">[^/]+)(?!.*\\sd/))" +
            ")(\\s|$)){0,10}", Pattern.CASE_INSENSITIVE);

    private static final TaskFieldParser TASK_PARSER = new TaskFieldParser();
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public AddCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {
            InferredDate startDate = TASK_PARSER.parseStartDate(matcher.group(REGEX_REF_START_DATE));
            InferredDate endDate = TASK_PARSER.parseEndDate(matcher.group(REGEX_REF_END_DATE));
            String taskName = TASK_PARSER.parseTaskName(matcher.group(REGEX_REF_TASK_NAME));
            String location = TASK_PARSER.parseLocation(matcher.group(REGEX_REF_LOCATION));
            PriorityLevel priority = TASK_PARSER.parsePriorityLevel(matcher.group(REGEX_REF_PRIORITY_LEVEL));
            RecurrenceType recurrence = TASK_PARSER.parseRecurrenceType(matcher.group(REGEX_REF_RECURRING_TYPE));
            Integer nrOfRecurrence = TASK_PARSER.parseNumberOfRecurrence(matcher.group(REGEX_REF_NUMBER_OF_RECURRENCE));
            String category = TASK_PARSER.parseCategory(matcher.group(REGEX_REF_CATEGORY));
            String description = TASK_PARSER.parseDescription(matcher.group(REGEX_REF_DESCRIPTION));

            return new AddCommand(taskName, startDate, 
                            endDate, location, priority, 
                            recurrence, nrOfRecurrence, 
                            category, description);
        }
        
        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }

}
```
###### \java\seedu\savvytasker\logic\parser\AliasCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.AliasCommand;

public class AliasCommandParser implements CommandParser<AliasCommand> {
    private static final String HEADER = "alias";
    private static final String READABLE_FORMAT = HEADER+" k/KEYWORD r/REPRESENTATION";
    
    private static final String REGEX_REF_REPRESENTATION = "Text";
    private static final String REGEX_REF_KEYWORD = "Keyword";
    
    private static final Pattern REGEX_PATTERN = Pattern.compile(
            HEADER+"\\s+((?<=\\s)(" +
                    "(r/(?<"+REGEX_REF_REPRESENTATION+">[^/]+)(?!.*\\sr/))|" +
                    "(k/(?<"+REGEX_REF_KEYWORD+">[^/]+)(?!.*\\sk/))" +
                    ")(\\s|$)){2}"
    );
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public boolean shouldPreprocess() {
        return false;
    }
    
    @Override
    public AliasCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {
            String representation = parseRepresentation(matcher.group(REGEX_REF_REPRESENTATION));
            String keyword = parseKeyword(matcher.group(REGEX_REF_KEYWORD));
            return new AliasCommand(keyword, representation);
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }
    
    private String parseRepresentation(String originalText) throws ParseException {
        String trimmedText = originalText.trim();
        
        if (trimmedText.isEmpty())
            throw new ParseException(trimmedText, "REPRESENTATION: Needs to be at least one character!");
        
        return trimmedText;
    }

    private String parseKeyword(String keywordText) throws ParseException {
        String trimmedKeywordText = keywordText.trim();
        if (trimmedKeywordText.length() < 2) {
            throw new ParseException(trimmedKeywordText, "KEYWORD: Needs to consist at least 2 character.");
        }
        if (trimmedKeywordText.matches(".*\\s+.*")) {
            throw new ParseException(trimmedKeywordText, "KEYWORD: Needs to be a single word without spaces.");
        }
        return trimmedKeywordText;
    }
}
```
###### \java\seedu\savvytasker\logic\parser\ClearCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.ClearCommand;

public class ClearCommandParser implements CommandParser<ClearCommand> {
    private static final String HEADER = "clear";
    private static final String READABLE_FORMAT = HEADER;
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public ClearCommand parse(String commandText) throws ParseException {
        if (commandText.trim().equalsIgnoreCase(HEADER)) {
            return new ClearCommand();
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }

}
```
###### \java\seedu\savvytasker\logic\parser\CommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import seedu.savvytasker.logic.commands.Command;

/**
 * This interface should be implemented by specialized parsers that want to 
 * parse a specific command. The text passed to such a parser will be 
 * guaranteed to have its header (the leading word) matching the String
 * returned by the abstract getHeader() method supplied by its implementation.
 *
 * @param <T> A Command that this Parser is going to produce upon successful parsing
 */
public interface CommandParser<T extends Command> {    
    /**
     * Indicates whether this parser would like to have the text supplied to it
     * preprocessed. The default behaviour is to allow preprocessing. 
     * Subclasses should override this method to return false if they do not want
     * the text to be preprocessed.
     * 
     * @return true if preprocessing is desired, false otherwise
     */
    public default boolean shouldPreprocess() {
        return true;
    }
    
    /**
     * Gets the header of this command parser.
     * The header is the first token of a command text, used to identify which 
     * CommandParser the command text will be dispatched to. Subclasses should
     * implement this method to indicate their header so that any command text that
     * starts with such a header will be given to them. This method should always 
     * return the same value, must return a string as a single token with no whitespaces 
     * in between, and must not return null or empty string.
     * 
     * @return header string
     */
    public String getHeader();
    
    /**
     * Gets the human-readable format of the string required by this command parser to 
     * parse correctly. Subclasses should implement this method to provide the above described.
     * This method should not return null, and should return the same value every time.
     * 
     * @return a human-readable format required by this parser
     */
    public String getRequiredFormat();
    
    /**
     * Parses the command text and returns the resulting command built from the parse.
     * Subclasses should implement this method to do their parsing. If the command text
     * is not as what they expect, subclasses should throw a ParseException.
     * 
     * @param commandText the full command text, including the header
     * @return the resulting command object which can then be executed
     * @throws ParseException if the commandText has an incorrect syntax
     */
    public T parse(String commandText) throws ParseException;
    
}
```
###### \java\seedu\savvytasker\logic\parser\DateParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.Date;
import java.util.List;
import java.util.Locale;

import com.joestelmach.natty.DateGroup;

public class DateParser {
    /**
     * Represents a date-time that may be partially inferred on its
     * date component or time component. If both components are not 
     * inferred, then the date-time is exactly as the user has specified
     * it to be.
     */
    public class InferredDate {
        private final Date inferredDateTime;
        private final boolean dateInferred;
        private final boolean timeInferred;
        
        public InferredDate(Date inferredDateTime, boolean dateInferred, boolean timeInferred) {
            this.inferredDateTime = inferredDateTime;
            this.dateInferred = dateInferred;
            this.timeInferred = timeInferred;
        }
        
        /**
         * Gets the inferred date-time.
         * @return the inferred date-time
         */
        public Date getInferredDateTime() {
            return this.inferredDateTime;
        }
        
        /**
         * Checks if the date component is inferred
         * @return true if inferred, false otherwise
         */
        public boolean isDateInferred() {
            return this.dateInferred;
        }
        
        /**
         * Checks if the time component is inferred
         * @return true if inferred, false otherwise
         */
        public boolean isTimeInferred() {
            return this.timeInferred;
        }
    }
    
    private com.joestelmach.natty.Parser nattyParser;
    
    public DateParser() {
        this.nattyParser = new com.joestelmach.natty.Parser();
    }
    
    /**
     * Parses an input for a single date. It is considered a parsing error 
     * if multiple dates are specified in the given input.
     * 
     * @param input the input to be parsed
     * @return an InferredDate object resulting from the parsing
     * @throws ParseException if the input contains multiple dates or no dates.
     */
    public InferredDate parseSingle(String input) throws ParseException {
        assert input != null;
        
        // Temporary workaround for natty's failure at adapting to locales dd-mm-yyyy, until
        // their issue is closed.
        if (!Locale.getDefault().equals(Locale.US)) {
            input = input.replaceAll("(\\d{1,2})-(\\d{1,2})-((?:\\d\\d){1,2})", "$2-$1-$3");
        }
        
        List<DateGroup> dateGroups = this.nattyParser.parse(input);
        int totalDates = countDates(dateGroups);
        
        if (totalDates == 0)
            throw new ParseException(input, "Failed to understand given date.");
        
        if (totalDates > 1)
            throw new ParseException(input, "Too many dates entered.");
        
        DateGroup group = dateGroups.get(0);
        
        
        
        return new InferredDate(
                group.getDates().get(0),
                group.isDateInferred(),
                group.isTimeInferred());
        
    }
    
    private int countDates(List<DateGroup> dateGroups) {
        int totalNumOfDates = 0;
        for(DateGroup group : dateGroups) {
            totalNumOfDates += group.getDates().size();
        }
        return totalNumOfDates;
    }
}
```
###### \java\seedu\savvytasker\logic\parser\DeleteCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.DeleteCommand;

public class DeleteCommandParser implements CommandParser<DeleteCommand> {
    private static final String HEADER = "delete";
    private static final String READABLE_FORMAT = HEADER+" INDEX [MORE_INDEX]";
    
    private static final String REGEX_REF_INDICES = "Indices";
    
    private static final Pattern REGEX_PATTERN = Pattern.compile(
            HEADER+"\\s+(?<"+REGEX_REF_INDICES+">[^/]+)", Pattern.CASE_INSENSITIVE);
    
    private static final IndexParser INDEX_PARSER = new IndexParser();
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public DeleteCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {
            int[] indices = parseIndices(matcher.group(REGEX_REF_INDICES));
            return new DeleteCommand(indices);
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }
    
    private int[] parseIndices(String indicesText) throws ParseException {
        try {
            return INDEX_PARSER.parseMultiple(indicesText);
        } catch (ParseException ex) {
            throw new ParseException(indicesText, String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat() + ": " + ex.getFailureDetails()));
        }
    }

}
```
###### \java\seedu\savvytasker\logic\parser\ExitCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.ExitCommand;

public class ExitCommandParser implements CommandParser<ExitCommand> {
    private static final String HEADER = "exit";
    private static final String READABLE_FORMAT = HEADER;
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public ExitCommand parse(String commandText) throws ParseException {
        if (commandText.trim().equalsIgnoreCase(HEADER)) {
            return new ExitCommand();
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }

}
```
###### \java\seedu\savvytasker\logic\parser\FindCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.FindCommand;
import seedu.savvytasker.model.task.FindType;

public class FindCommandParser implements CommandParser<FindCommand> {
    private static final String HEADER = "find";
    private static final String READABLE_FORMAT = "find [t/FIND_TYPE] KEYWORD [MORE_KEYWORDS]";

    private static final String REGEX_REF_KEYWORDS_BEFORE_TYPE = "Before";
    private static final String REGEX_REF_FIND_TYPE = "FindType";
    private static final String REGEX_REF_KEYWORDS_AFTER_TYPE = "After";
    
    private static final Pattern REGEX_PATTERN = Pattern.compile(
            HEADER+"\\s+(?<"+REGEX_REF_KEYWORDS_BEFORE_TYPE+">([^/]+(\\s+|$))*)" +
            "(t/(?<"+REGEX_REF_FIND_TYPE+">[^/]+?)(?!.*\\st/)(\\s+|$))?" +
            "(?<"+REGEX_REF_KEYWORDS_AFTER_TYPE+">([^/]+(\\s+|$))*)"
            , Pattern.CASE_INSENSITIVE);
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

```
###### \java\seedu\savvytasker\logic\parser\HelpCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.HelpCommand;

public class HelpCommandParser implements CommandParser<HelpCommand> {
    private static final String HEADER = "help";
    private static final String READABLE_FORMAT = HEADER;
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public HelpCommand parse(String commandText) throws ParseException {
        if (commandText.trim().equalsIgnoreCase(HEADER)) {
            return new HelpCommand();
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }

}
```
###### \java\seedu\savvytasker\logic\parser\IndexParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.Arrays;

/**
 * A class for parsing a single index or multiple indices. An index is 
 * a positive integer that may be used by commands to indicate which task
 * they act on.
 */
public class IndexParser {    
    public static String INDEX_MUST_BE_POSITIVE = "Must be positive whole numbers.";
    /**
     * Parses a single index.
     * 
     * @param indexText the text to parse
     * @return the resulting index
     * @throws ParseException if there are more than one integer in the text, or if 
     *      the integer given is not positive
     */
    public int parseSingle(String indexText) throws ParseException {
        boolean parseError = false;

        String trimmedIndexText = indexText.trim();
        int index = 0;
        try {
            index = Integer.parseInt(trimmedIndexText);
            
            if (index <= 0)
                parseError = true;
        } catch (NumberFormatException ex) {
            parseError = true;
        }
        
        if (parseError)
            throw new ParseException(trimmedIndexText, "Must be a positive whole number.");
            
        return index;
    }
    
    /**
     * Parses multiple indices, delimited by space.
     * 
     * @param indicesText the text to parse
     * @return an array of the resulting indices
     * @throws ParseException if any of the indices is not a positive integer
     */
    public int[] parseMultiple(String indicesText) throws ParseException {
        boolean parseError = false;

        String trimmedIndicesText = indicesText.trim();
        int[] indices = null;
        try {
            indices = Arrays
                .stream(trimmedIndicesText.split("\\s+"))
                .mapToInt(Integer::parseInt)
                .toArray();
            
            for(int index : indices) {
                if (index <= 0) {
                    parseError = true;
                    break;
                }
            }
        } catch (NumberFormatException ex) {
            parseError = true;
        }
        
        if (parseError)
            throw new ParseException(trimmedIndicesText, INDEX_MUST_BE_POSITIVE);
            
        return indices;
    }
}
```
###### \java\seedu\savvytasker\logic\parser\ListCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.ListCommand;
import seedu.savvytasker.model.task.ListType;

public class ListCommandParser implements CommandParser<ListCommand> {
    private static final String HEADER = "list";
    private static final String READABLE_FORMAT = HEADER+" [t/LIST_TYPE]";
    
    private static final String REGEX_REF_LIST_TYPE = "ListType";
    
    private static final Pattern REGEX_PATTERN = Pattern.compile(
            HEADER+"\\s*((?<=\\s)t/(?<"+REGEX_REF_LIST_TYPE+">[^/]+))?",
            Pattern.CASE_INSENSITIVE);
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public ListCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {
            ListType listType = parseListType(matcher.group(REGEX_REF_LIST_TYPE));
            
            return new ListCommand(listType);
        }
        
        throw new ParseException(commandText, String.format(
            Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }

    private ListType parseListType(String listTypeText) throws ParseException {
        if (listTypeText == null)
            return null;
        
        try {
            listTypeText = listTypeText.trim();
            return ListType.valueOfIgnoreCase(listTypeText.replaceAll("\\s", ""));
        } catch (IllegalArgumentException ex) {
            throw new ParseException(listTypeText, "LIST_TYPE: Unknown type '" + listTypeText + "'");
        }
    }
}
```
###### \java\seedu\savvytasker\logic\parser\MarkCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.MarkCommand;

public class MarkCommandParser implements CommandParser<MarkCommand> {
    private static final String HEADER = "mark";
    private static final String READABLE_FORMAT = HEADER+" INDEX [MORE_INDEX]";
    
    private static final String REGEX_REF_INDICES = "Indices";
    
    private static final Pattern REGEX_PATTERN = Pattern.compile(
            HEADER+"\\s+(?<"+REGEX_REF_INDICES+">[^/]+)", Pattern.CASE_INSENSITIVE);
    
    private static final IndexParser INDEX_PARSER = new IndexParser();
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public MarkCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {
            int[] indices = parseIndices(matcher.group(REGEX_REF_INDICES));
            return new MarkCommand(indices);
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }
    
    private int[] parseIndices(String indicesText) throws ParseException {
        try {
            return INDEX_PARSER.parseMultiple(indicesText);
        } catch (ParseException ex) {
            throw new ParseException(indicesText, "INDEX [MORE_INDEX]: " + ex.getFailureDetails());
        }
    }

}
```
###### \java\seedu\savvytasker\logic\parser\MasterParser.java
``` java
package seedu.savvytasker.logic.parser;

import static seedu.savvytasker.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.savvytasker.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.logic.commands.Command;
import seedu.savvytasker.logic.commands.HelpCommand;
import seedu.savvytasker.logic.commands.IncorrectCommand;
import seedu.savvytasker.model.alias.AliasSymbol;

public class MasterParser {
    private static final Pattern KEYWORD_PATTERN = 
            Pattern.compile("(\\S+)(\\s+|$)");
    
    private final Map<String, CommandParser<? extends Command>> commandParsers;
    private final Map<String, AliasSymbol> aliasingSymbols;
    
    public MasterParser() {
        this.commandParsers = new HashMap<String, CommandParser<? extends Command>>();
        this.aliasingSymbols = new HashMap<String, AliasSymbol>();
    }

    public Command parse(String userInput) {
        String[] pieces = preprocessInitial(userInput.trim());
        if (pieces == null) 
            return new IncorrectCommand(userInput, String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        
        String header = pieces[0];
        String body = pieces[1];
        String trueHeader = extractHeader(header);
        CommandParser<? extends Command> parser = commandParsers.get(trueHeader);
        if (parser == null)
            return new IncorrectCommand(header + body, String.format(MESSAGE_UNKNOWN_COMMAND, HelpCommand.MESSAGE_USAGE));
        if (parser.shouldPreprocess())
            body = preprocessBody(body);
        
        String combined = header + body;
        try {
            return parser.parse(combined);
        } catch (ParseException pe) {
            return new IncorrectCommand(combined, String.format(pe.getFailureDetails()));
        }
    }
    
    /**
     * Does an initial preprocessing of a command text in case the header is aliased.
     * Returns a string array with 2 elements: the first is the header which is possibly aliased,
     * which will be replaced with the representation of the aliasing, whereas the 
     * second is the body. If no header is found, this method returns null.
     * 
     * @param commandText the command text
     * @return a string array containing 2 elements, first is the header, second is the body; or null if
     * there is no header in the command text
     */
    private String[] preprocessInitial(String commandText) {
        Matcher matcher = KEYWORD_PATTERN.matcher(commandText);
        
        if (matcher.find()) {
            String header = matcher.group(1);
            String spaces = matcher.group(2);

            AliasSymbol symbol = aliasingSymbols.get(header);
            if (symbol != null) {
                header = symbol.getRepresentation();
            }
            
            String body = commandText.substring(matcher.end());
            return new String[] {header + spaces, body};
        }
        
        return null;
    }
    
    /**
     * Gets the header from the preprocessed header as a preprocessed header may contain
     * several tokens.
     * 
     * @param preprocessedHeader the preprocessed header
     * @return the true header
     */
    private String extractHeader(String preprocessedHeader) {
        Matcher matcher = KEYWORD_PATTERN.matcher(preprocessedHeader);
        
        if (matcher.find()) {
            return matcher.group(1);
        }
        
        return null;
    }
    
    /**
     * Preprocess the body to replace keywords with their replacement if they are aliased.
     * @param bodyText the body text
     * @return the preprocessed body text
     */
    private String preprocessBody(String bodyText) {
        StringBuilder builder = new StringBuilder();
        Matcher matcher = KEYWORD_PATTERN.matcher(bodyText);
        
        while (matcher.find()) {
            String keyword = matcher.group(1);
            String spaces = matcher.group(2); // Preserves the amount of spaces as that may be what user wants
            
            AliasSymbol symbol = aliasingSymbols.get(keyword);
            if (symbol != null)
                keyword = symbol.getRepresentation();
            
            builder.append(keyword);
            builder.append(spaces);            
        }
        
        return builder.toString();
    }
    
    /**
     * Registers a command parser that will be used by the master parser, and return true if it
     * is successfully registered. The header of this command parser should not be used by any 
     * other registered command parsers or used by any AliasSymbol whose keyword is the registered
     * with the same name, or false will be return and the parser will not be added. Use 
     * {@link #isCommandParserRegistered(String) isCommandParserRegistered } method to check if 
     * a command parser is already registered, and {@link #doesAliasSymbolExist(String) doesAliasSymbolExist}
     * 
     * Parameter commandParser should not be null.
     * 
     * @param commandParser the command parser
     * @return true if successfully registered, false if there is an parser with the same header 
     * already registered or if an alias with the same keyword is previously added.
     */
    public boolean registerCommandParser(CommandParser<? extends Command> commandParser) {
        assert commandParser != null;
        
        if (commandParsers.containsKey(commandParser.getHeader()))
            return false;
        if (aliasingSymbols.containsKey(commandParser.getHeader()))
            return false;
        
        commandParsers.put(commandParser.getHeader(), commandParser);   
        return true;
    }
    
    /**
     * Checks if a command parser with the specified header is already 
     * registered into the master parser.
     * 
     * @param header the header to check against
     * @return true if such a command parser is registered, false otherwise
     */
    public boolean isCommandParserRegistered(String header) {
        return commandParsers.containsKey(header);
    }
    
    /**
     * Unregisters and returns the command parser that uses the specified header.
     * If such a parser is not registered, null is returned.
     * 
     * @param header the header to check against
     * @return the CommandParser object that uses the specified header.
     */
    public CommandParser<? extends Command> unregisterCommandParser(String header) {
        return commandParsers.remove(header);
    }

    /**
     * Adds an aliasing symbol to be used by the parser to replace all such the symbol's keyword with 
     * its representation before parsing. If a symbol with an identical keyword exists, calling this
     * method has no effect and just returns false.
     * 
     * @param symbol the symbol, cannot be null.
     * @return true if this symbol is added successfully, false if another symbol with the same keyword
     * already exists or the keyword is used by a command and this symbol cannot be added.
     */
    public boolean addAliasSymbol(AliasSymbol symbol) {
        assert symbol != null;
        
        if (aliasingSymbols.containsKey(symbol.getKeyword()))
            return false;
        if (isCommandParserRegistered(symbol.getKeyword()))
            return false;
        
        aliasingSymbols.put(symbol.getKeyword(), symbol);
        return true;
    }
    
    /**
     * Removes an aliasing symbol, identified by its keyword. The parser will no longer replace the 
     * keyword of this symbol with its representation before parsing.
     * 
     * @param symbol the symbol to remove, cannot be null
     * @return true if the symbol exists and is removed, false otherwise
     */
    public boolean removeAliasSymbol(String symbolKeyword) {
        assert symbolKeyword != null;
        
        return aliasingSymbols.remove(symbolKeyword) != null;
    }
    
    /**
     * Returns true if a symbol with the specified keyword exists, false otherwise.
     * @param symbolKeyword the keyword to check for, cannot be null
     * @return true if the symbol exists, false otherwise
     */
    public boolean doesAliasSymbolExist(String symbolKeyword) {
        assert symbolKeyword != null;
        
        return aliasingSymbols.containsKey(symbolKeyword);
    }
    
    /**
     * Clears all existing symbols.
     * @see #removeAliasSymbol
     */
    public void clearAllAliasSymbols() {
        aliasingSymbols.clear();
    }
}
```
###### \java\seedu\savvytasker\logic\parser\ModifyCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.ModifyCommand;
import seedu.savvytasker.logic.parser.DateParser.InferredDate;
import seedu.savvytasker.model.task.PriorityLevel;
import seedu.savvytasker.model.task.RecurrenceType;

public class ModifyCommandParser implements CommandParser<ModifyCommand> {
    private static final String HEADER = "modify";
    private static final String READABLE_FORMAT = HEADER+" INDEX [t/TASK_NAME] [s/START_DATE] "
            + "[e/END_DATE] [l/LOCATION] [p/PRIORITY_LEVEL] [r/RECURRING_TYPE] "
            + "[n/NUMBER_OF_RECURRENCE] [c/CATEGORY] [d/DESCRIPTION]";

    private static final String REGEX_REF_INDEX = "Index";
    private static final String REGEX_REF_TASK_NAME = "TaskName";
    private static final String REGEX_REF_START_DATE = "StartDate";
    private static final String REGEX_REF_END_DATE = "EndDate";
    private static final String REGEX_REF_LOCATION = "Location";
    private static final String REGEX_REF_PRIORITY_LEVEL = "Priority";
    private static final String REGEX_REF_RECURRING_TYPE = "RecurringType";
    private static final String REGEX_REF_NUMBER_OF_RECURRENCE = "RecurringNumber";
    private static final String REGEX_REF_CATEGORY = "Category";
    private static final String REGEX_REF_DESCRIPTION = "Description";
    
    private static final Pattern REGEX_PATTERN = Pattern.compile(
            HEADER+"\\s+(?<"+REGEX_REF_INDEX+">([^/]+?(\\s+|$))+)((?<=\\s)(" +
            "(t/(?<"+REGEX_REF_TASK_NAME+">[^/]*)(?!.*\\st/))|" +
            "(s/(?<"+REGEX_REF_START_DATE+">[^/]*)(?!.*\\ss/))|" +
            "(e/(?<"+REGEX_REF_END_DATE+">[^/]*)(?!.*\\se/))|" +
            "(l/(?<"+REGEX_REF_LOCATION+">[^/]*)(?!.*\\sl/))|" +
            "(p/(?<"+REGEX_REF_PRIORITY_LEVEL+">[^/]+)(?!.*\\sp/))|" +
            "(r/(?<"+REGEX_REF_RECURRING_TYPE+">[^/]+)(?!.*\\sr/))|" +
            "(n/(?<"+REGEX_REF_NUMBER_OF_RECURRENCE+">[^/]+)(?!.*\\sn/))|" +
            "(c/(?<"+REGEX_REF_CATEGORY+">[^/]*)(?!.*\\sc/))|" +
            "(d/(?<"+REGEX_REF_DESCRIPTION+">[^/]*)(?!.*\\sd/))" +
            ")(\\s|$)){0,11}", Pattern.CASE_INSENSITIVE);

    private static final TaskFieldParser TASK_PARSER = new TaskFieldParser();
    private static final IndexParser INDEX_PARSER = new IndexParser();
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public ModifyCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {

            int index = parseIndex(matcher.group(REGEX_REF_INDEX));
            InferredDate startDate = parseDate(matcher.group(REGEX_REF_START_DATE));
            InferredDate endDate = parseDate(matcher.group(REGEX_REF_END_DATE));
            String taskName = TASK_PARSER.parseTaskName(matcher.group(REGEX_REF_TASK_NAME));
            String location = TASK_PARSER.parseLocation(matcher.group(REGEX_REF_LOCATION));
            PriorityLevel priority = TASK_PARSER.parsePriorityLevel(matcher.group(REGEX_REF_PRIORITY_LEVEL));
            RecurrenceType recurrence = TASK_PARSER.parseRecurrenceType(matcher.group(REGEX_REF_RECURRING_TYPE));
            Integer nrOfRecurrence = TASK_PARSER.parseNumberOfRecurrence(matcher.group(REGEX_REF_NUMBER_OF_RECURRENCE));
            String category = TASK_PARSER.parseCategory(matcher.group(REGEX_REF_CATEGORY));
            String description = TASK_PARSER.parseDescription(matcher.group(REGEX_REF_DESCRIPTION));
            
            return new ModifyCommand(index, taskName, startDate, 
                            endDate, location, priority, 
                            recurrence, nrOfRecurrence, 
                            category, description);
        }
        
        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }

    private int parseIndex(String indexText) throws ParseException {
        try {
            return INDEX_PARSER.parseSingle(indexText);
        } catch (ParseException ex) {
            throw new ParseException(indexText, "INDEX: " + ex.getFailureDetails());
        }
    }
    
    private InferredDate parseDate(String dateText) throws ParseException {
        if (dateText != null && dateText.trim().isEmpty()) {
            return TASK_PARSER.dateParser.new InferredDate(new Date(), true, true);
        }
        
        return TASK_PARSER.parseStartDate(dateText);
    }
}
```
###### \java\seedu\savvytasker\logic\parser\ParseException.java
``` java
package seedu.savvytasker.logic.parser;

/**
 * This exception should be thrown by parsers when they are unable to
 * parse a string of tokens.
 */
public class ParseException extends Exception {
    private static final long serialVersionUID = -1157747299012674373L;
    private final String parsedString;
    private final String failureDetails;
    
    /**
     * Constructs a ParseException object with the original string that
     * the parser failed to parse, with no further details to why the 
     * parser failed to parse the string
     * 
     * @param parsedString the erroneous string
     */
    public ParseException(String parsedString) {
        this(parsedString, "");
    }
    
    /**
     * Constructs a ParseException object with the original string that
     * the parser failed to parse, and further details to why the parser
     * failed to parse the string.
     * 
     * @param parsedString the erroneous string
     * @param failureDetails the failure details
     */
    public ParseException(String parsedString, String failureDetails) {
        super("Failed to parse " + parsedString + ". " + failureDetails);
        this.parsedString = parsedString;
        this.failureDetails = failureDetails;
    }
    
    public String getParsedString() {
        return this.parsedString;
    }
    
    public String getFailureDetails() {
        return this.failureDetails;
    }
}
```
###### \java\seedu\savvytasker\logic\parser\RedoCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.RedoCommand;

public class RedoCommandParser implements CommandParser<RedoCommand> {
    private static final String HEADER = "redo";
    private static final String READABLE_FORMAT = HEADER;
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public RedoCommand parse(String commandText) throws ParseException {
        if (commandText.trim().equalsIgnoreCase(HEADER)) {
            return new RedoCommand();
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }

}
```
###### \java\seedu\savvytasker\logic\parser\TaskFieldParser.java
``` java
package seedu.savvytasker.logic.parser;

import seedu.savvytasker.logic.parser.DateParser.InferredDate;
import seedu.savvytasker.model.task.PriorityLevel;
import seedu.savvytasker.model.task.RecurrenceType;

/**
 * This class contains common parsing methods for parsing Task fields.
 */
public class TaskFieldParser {
    protected final DateParser dateParser;
    
    public TaskFieldParser() {
        this.dateParser = new DateParser();
    }
    
    public String parseTaskName(String taskNameText) throws ParseException {
        if (taskNameText == null)
            return null;
        return taskNameText.trim();
    }
    
    public InferredDate parseStartDate(String dateText) throws ParseException {
        return parseDate(dateText, "START_DATE: ");
    }
    
    public InferredDate parseEndDate(String dateText) throws ParseException {
        return parseDate(dateText, "END_DATE: ");
    }
    
    private InferredDate parseDate(String dateText, String errorField) throws ParseException {
        if (dateText == null)
            return null;
        
        String trimmedDateText = dateText.trim();
        try {
            return dateParser.parseSingle(trimmedDateText);
        } catch (ParseException ex) {
            throw new ParseException(trimmedDateText, errorField + ex.getFailureDetails());
        }
    }
    
    public String parseLocation(String locationText) throws ParseException {
        if (locationText == null)
            return null;
        return locationText.trim();
    }
    
    public PriorityLevel parsePriorityLevel(String priorityLevelText) throws ParseException {
        if (priorityLevelText == null)
            return null;
        
        String trimmedPriorityLevelText = priorityLevelText.trim();
        try {
            return PriorityLevel.valueOfIgnoreCase(trimmedPriorityLevelText);
        } catch (IllegalArgumentException ex) {
            throw new ParseException(trimmedPriorityLevelText, "PRIORITY_LEVEL: Unknown type '" + priorityLevelText + "'");
        }
    }
    
    public RecurrenceType parseRecurrenceType(String recurrenceTypeText) throws ParseException {
        if (recurrenceTypeText == null)
            return null;
        
        String trimmedRecurrenceTypeText = recurrenceTypeText.trim();
        try {
            return RecurrenceType.valueOfIgnoreCase(trimmedRecurrenceTypeText);
        } catch (IllegalArgumentException ex) {
            throw new ParseException(trimmedRecurrenceTypeText, "RECURRING_TYPE: Unknown type '" + recurrenceTypeText + "'");
        }
    }
    
    public Integer parseNumberOfRecurrence(String numRecurrenceText) throws ParseException {
        if (numRecurrenceText == null)
            return null;
        
        String trimmedNumRecurrenceText = numRecurrenceText.trim();
        int numRecurrence = 0;
        boolean parseError = false;
        
        try {
            numRecurrence = Integer.parseInt(trimmedNumRecurrenceText);
            if (numRecurrence < 0)
                parseError = true;
        } catch (NumberFormatException ex) {
            parseError = true;
        }
        
        if (parseError)
            throw new ParseException(trimmedNumRecurrenceText, "NUMBER_OF_RECURRENCE: Must be a nonnegative whole number!");
        
        return numRecurrence;
    }

    public String parseCategory(String categoryText) throws ParseException {
        if (categoryText == null)
            return null;
        return categoryText.trim();
    }
    
    public String parseDescription(String descriptionText) throws ParseException {
        if (descriptionText == null)
            return null;
        return descriptionText.trim();
    }
}
```
###### \java\seedu\savvytasker\logic\parser\UnaliasCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.UnaliasCommand;

public class UnaliasCommandParser implements CommandParser<UnaliasCommand> {
    private static final String HEADER = "unalias";
    private static final String READABLE_FORMAT = HEADER+" KEYWORD";
    
    private static final String REGEX_REF_KEYWORD = "Keyword";
    
    private static final Pattern REGEX_PATTERN = Pattern.compile(
            HEADER+"\\s+(?<"+REGEX_REF_KEYWORD+">[^/]+)"
    );
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }
    
    @Override
    public boolean shouldPreprocess() {
        return false;
    }

    @Override
    public UnaliasCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {
            String keyword = parseKeyword(matcher.group(REGEX_REF_KEYWORD));
            return new UnaliasCommand(keyword);
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }

    private String parseKeyword(String keywordText) throws ParseException {
        String trimmedKeywordText = keywordText.trim();
        if (trimmedKeywordText.isEmpty()) {
            throw new ParseException(trimmedKeywordText, "KEYWORD: Cannot be empty.");
        }
        return trimmedKeywordText;
    }

}
```
###### \java\seedu\savvytasker\logic\parser\UndoCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.UndoCommand;

public class UndoCommandParser implements CommandParser<UndoCommand> {
    private static final String HEADER = "undo";
    private static final String READABLE_FORMAT = HEADER;
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public UndoCommand parse(String commandText) throws ParseException {
        if (commandText.trim().equalsIgnoreCase(HEADER)) {
            return new UndoCommand();
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }

}
```
###### \java\seedu\savvytasker\logic\parser\UnmarkCommandParser.java
``` java
package seedu.savvytasker.logic.parser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.savvytasker.commons.core.Messages;
import seedu.savvytasker.logic.commands.UnmarkCommand;

public class UnmarkCommandParser implements CommandParser<UnmarkCommand> {
    private static final String HEADER = "unmark";
    private static final String READABLE_FORMAT = HEADER+" INDEX [MORE_INDEX]";
    
    private static final String REGEX_REF_INDICES = "Indices";
    
    private static final Pattern REGEX_PATTERN = Pattern.compile(
            HEADER+"\\s+(?<"+REGEX_REF_INDICES+">[^/]+)", Pattern.CASE_INSENSITIVE);
    
    private static final IndexParser INDEX_PARSER = new IndexParser();
    
    @Override
    public String getHeader() {
        return HEADER;
    }

    @Override
    public String getRequiredFormat() {
        return READABLE_FORMAT;
    }

    @Override
    public UnmarkCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {
            int[] indices = parseIndices(matcher.group(REGEX_REF_INDICES));
            
            // TODO: Integrate UnmarkCommand properly!
            return new UnmarkCommand(indices);
        }

        throw new ParseException(commandText, String.format(
                Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }
    
    private int[] parseIndices(String indicesText) throws ParseException {
        try {
            return INDEX_PARSER.parseMultiple(indicesText);
        } catch (ParseException ex) {
            throw new ParseException(indicesText, "INDEX [MORE_INDEX]: " + ex.getFailureDetails());
        }
    }

}
```
###### \java\seedu\savvytasker\model\alias\AliasSymbol.java
``` java
package seedu.savvytasker.model.alias;

import java.util.Objects;

/**
 * A class that represents a keyword-representation pair. This pair can be used 
 * by the parser for substituting keywords found in a commandText with its
 * representation. Instances of this class are immutable.
 */
public class AliasSymbol {
    private final String keyword;
    private final String representation;
    
    /**
     * Creates a Symbol object with the specified keyword and its representation.
     * The keyword must be a single word without spaces while the representation
     * can be any non-empty string. Both parameters cannot be null.
     * 
     * @param keyword
     * @param representation
     */
    public AliasSymbol(String keyword, String representation) {
        assert keyword != null && !keyword.matches(".*\\s+.*");
        assert representation != null && !representation.isEmpty();
        
        this.keyword = keyword;
        this.representation = representation;
    }
    
    public String getKeyword() {
        return this.keyword;
    }
    
    public String getRepresentation() {
        return this.representation;
    }
    
    @Override
    public String toString() {
        return "[Keyword: " + this.keyword + ", Representation: " + this.representation + "]";
    }

    @Override
    public boolean equals(Object object) {
        return this == object || (object instanceof AliasSymbol &&
                this.keyword.equals(((AliasSymbol)object).keyword) &&
                this.representation.equals(((AliasSymbol)object).representation));
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(keyword, representation);
    }
}
```
###### \java\seedu\savvytasker\model\alias\AliasSymbolList.java
``` java
package seedu.savvytasker.model.alias;

import java.util.Iterator;
import java.util.List;

import edu.emory.mathcs.backport.java.util.Collections;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

public class AliasSymbolList implements Iterable<AliasSymbol> {
    private final ObservableList<AliasSymbol> internalList = FXCollections.observableArrayList();
    
    /** Default constructor */
    public AliasSymbolList() {}
    
    /**
     * Copy constructor
     * @param src the list to copy from, cannot be null
     */
    public AliasSymbolList(AliasSymbolList src) {
        assert src != null;
        internalList.addAll(src.internalList);
    }
    
    @Override
    public Iterator<AliasSymbol> iterator() {
        return internalList.iterator();
    }
    
    /**
     * Returns true if a symbol with the specified symbolKeyword exists in the list
     * @param symbolKeyword the symbolKeyword to check for
     * @return true if exists, false otherwise
     */
    public boolean contains(String symbolKeyword) {
        for (AliasSymbol symbol : internalList) {
            if (symbol.getKeyword().equals(symbolKeyword))
                return true;
        }
        
        return false;
    }
    
    /**
     * Returns true if the symbol exists in the list. Both keyword and representation must match.
     * @param symbol the symol to check for
     * @return true if exists, false otherwise
     */
    public boolean contains(AliasSymbol symbol) {
        return internalList.contains(symbol);
    }
    
    /**
     * Adds a symbol to the list. The symbol being added must not have a keyword that clashes with another
     * symbol in the list.
     * @param symbol the symbol to add, cannot be null
     * @throws DuplicateSymbolKeywordException if a symbol with the same keyword already exists
     */
    public void addAliasSymbol(AliasSymbol symbol) throws DuplicateSymbolKeywordException {
        assert symbol != null;
        if (contains(symbol.getKeyword()))
            throw new DuplicateSymbolKeywordException();
        internalList.add(symbol);
    }
    
    /**
     * Removes a symbol from the list.
     * @param symbol the symbol to remove, cannot be null
     * @throws SymbolKeywordNotFoundException if no such symbol can be found.
     */
    public void removeAliasSymbol(AliasSymbol symbol) throws SymbolKeywordNotFoundException {
        assert symbol != null;
        if (!contains(symbol))
            throw new SymbolKeywordNotFoundException();
        internalList.remove(symbol);        
    }
    
    /**
     * Replace an old symbol with a new symbol. The new symbol's keyword must equal to the old
     * symbol's keyword.
     * 
     * @param oldSymbol the old symbol to be replaced, cannot be null
     * @param newSymbol the new symbol to used to replace, cannot be null
     * @throws SymbolKeywordNotFoundException if an old symbol with the keyword is not found.
     */
    public void replaceAliasSymbol(AliasSymbol oldSymbol, AliasSymbol newSymbol) throws SymbolKeywordNotFoundException {
        assert oldSymbol != null && newSymbol != null;
        assert oldSymbol.getKeyword().equals(newSymbol.getKeyword());
        
        removeAliasSymbol(oldSymbol);
        internalList.add(newSymbol);
    }
    
    /**
     * Clears this list and copy all elements from the other list to this.
     * @param other the other list
     */
    public void reset(AliasSymbolList other) {
        assert other != null;
        internalList.addAll(other.internalList); // AliasSymbol is immutable, no need for deep copy.
    }
    
    /**
     * Gets the size of this list.
     * @return the size of this list
     */
    public int size() {
        return internalList.size();
    }
    
    public List<AliasSymbol> asReadonly() {
        return Collections.unmodifiableList(internalList);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AliasSymbolList // instanceof handles nulls
                && this.internalList.equals( ((AliasSymbolList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### \java\seedu\savvytasker\model\alias\DuplicateSymbolKeywordException.java
``` java
package seedu.savvytasker.model.alias;

import seedu.savvytasker.commons.exceptions.IllegalValueException;

public class DuplicateSymbolKeywordException extends IllegalValueException {
    private static final long serialVersionUID = -5516547118656055929L;

    public DuplicateSymbolKeywordException() {
        super("Operation will result in two symbols with the same keyword defined.");
    }
}
```
###### \java\seedu\savvytasker\model\alias\SymbolKeywordNotFoundException.java
``` java
package seedu.savvytasker.model.alias;

import seedu.savvytasker.commons.exceptions.IllegalValueException;

public class SymbolKeywordNotFoundException extends IllegalValueException {
    private static final long serialVersionUID = -5516547118656055929L;

    public SymbolKeywordNotFoundException() {
        super("Unable to find a symbol with the specified keyword.");
    }
}
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java

    private void indicateAliasSymbolAdded(AliasSymbol symbol) {
        raise(new AliasSymbolChangedEvent(symbol, AliasSymbolChangedEvent.Action.Added));
    }
    
    private void indicateAliasSymbolRemoved(AliasSymbol symbol) {
        raise(new AliasSymbolChangedEvent(symbol, AliasSymbolChangedEvent.Action.Removed));
    }
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
    @Override
    public synchronized void addAliasSymbol(AliasSymbol symbol) throws DuplicateSymbolKeywordException {
        savvyTasker.addAliasSymbol(symbol);
        indicateSavvyTaskerChanged();
        indicateAliasSymbolAdded(symbol);
    }

    @Override
    public synchronized void removeAliasSymbol(AliasSymbol symbol) throws SymbolKeywordNotFoundException {
        savvyTasker.removeAliasSymbol(symbol);
        indicateSavvyTaskerChanged();
        indicateAliasSymbolRemoved(symbol);
    }
```
###### \java\seedu\savvytasker\model\ReadOnlySavvyTasker.java
``` java

    /**
     * Returns a defensively copied alias symbol list.
     */
    
    AliasSymbolList getAliasSymbolList();
```
###### \java\seedu\savvytasker\model\ReadOnlySavvyTasker.java
``` java

    /**
     * Returns unmodifiable view of symbols list
     */
    List<AliasSymbol> getReadOnlyListOfAliasSymbols();
```
###### \java\seedu\savvytasker\model\SavvyTasker.java
``` java
    
    /**
     * Adds an alias symbol to savvy tasker.
     * @param symbol the symbol to add
     * @throws DuplicateSymbolKeywordException if another symbol with the same keyword already exists
     */
    public void addAliasSymbol(AliasSymbol symbol) throws DuplicateSymbolKeywordException {
        symbols.addAliasSymbol(symbol);
    }
    
    /**
     * Removes an alias symbol from savvy tasker.
     * @param symbol the symbol to remove
     * @throws SymbolKeywordNotFoundException  if there is no such symbol
     */
    public void removeAliasSymbol(AliasSymbol symbol) throws SymbolKeywordNotFoundException {
        symbols.removeAliasSymbol(symbol);
    }
```
###### \java\seedu\savvytasker\model\SavvyTasker.java
``` java
    @Override
    public List<AliasSymbol> getReadOnlyListOfAliasSymbols() {
        return symbols.asReadonly();
    }

    @Override
    public AliasSymbolList getAliasSymbolList() {
        return new AliasSymbolList(symbols);
    }
```
###### \java\seedu\savvytasker\model\task\FindType.java
``` java
package seedu.savvytasker.model.task;

/**
 * This enum represents the type of matching used when trying to find tasks 
 * from keywords.
 */
public enum FindType {
    /**
     * Specifies partial matching of a single keyword.
     * Searches by Task's name.
     * E.g. 'ap' matches 'happy'
     */
    Partial,
    /**
     * Specifies full matching of a single keyword.
     * Searches by Task's name.
     * E.g. 'ap' does not match 'happy', 'happy' matches 'very happy'
     */
    Full,
    /**
     * Specifies full matching of all keywords in a set of keywords.
     * Searches by Task's name.
     * E.g. 'happy' does not match 'very happy', 'very happy' matches 'very happy'
     */
    Exact,
    /**
     * Specifies partial matching of all keywords in a set of keywords.
     * Searches by Task's category.
     * E.g. 'happy' does not match 'very happy', 'very happy' matches 'very happy'
     */
    Category;
    
    /**
     * Gets a FindType enum object from its enum name, ignoring cases.
     * @param name the name of the FindType enum object
     * @return the corresponding FindType enum object
     */
    public static FindType valueOfIgnoreCase(String name) {
        for (FindType type : FindType.values()) {
            if (type.toString().equalsIgnoreCase(name))
                return type;
        }
        
        throw new IllegalArgumentException("Unknown find type: " + name);
    }
}
```
###### \java\seedu\savvytasker\model\task\ListType.java
``` java
package seedu.savvytasker.model.task;

/**
 * This enum represents the different ways to list tasks.
 */
public enum ListType {
    /**
     * List tasks by due date.
     */
    DueDate,
    
    /**
     * List tasks by priority level.
     */
    PriorityLevel,
    
    /**
     * List archived tasks.
     */
    Archived;
    
    /**
     * Gets a ListType enum object from its enum name, ignoring cases.
     * @param name the name of the ListType enum object
     * @return the corresponding ListType enum object
     */
    public static ListType valueOfIgnoreCase(String name) {
        for (ListType type : ListType.values()) {
            if (type.toString().equalsIgnoreCase(name))
                return type;
        }
        
        throw new IllegalArgumentException("Unknown list type: " + name);
    }
}
```
###### \java\seedu\savvytasker\model\task\PriorityLevel.java
``` java
package seedu.savvytasker.model.task;

/**
 * This enum represents the priority level of tasks.
 */
public enum PriorityLevel {
    Low,
    Medium,
    High;

    /**
     * Gets a PriorityLevel enum object from its enum name, ignoring cases.
     * @param name the name of the PriorityLevel enum object
     * @return the corresponding PriorityLevel enum object
     */
    public static PriorityLevel valueOfIgnoreCase(String name) {
        for (PriorityLevel type : PriorityLevel.values()) {
            if (type.toString().equalsIgnoreCase(name))
                return type;
        }
        
        throw new IllegalArgumentException("Unknown priority level: " + name);
    }
}
```
###### \java\seedu\savvytasker\model\task\RecurrenceType.java
``` java
package seedu.savvytasker.model.task;

/**
 * This enum represents the type of recurrence of a recurring task.
 */
public enum RecurrenceType {
    /**
     * Specifies no recurrence i.e. the task is a one-time task.
     */
    None,
    /**
     * Specifies daily recurrence.
     */
    Daily,
    /**
     * Specifies weekly recurrence.
     */
    Weekly,
    /**
     * Specifies monthly recurrence.
     */
    Monthly,
    /**
     * Specifies yearly recurrence.
     */
    Yearly;     
    
    /**
     * Gets a RecurrenceType enum object from its enum name, ignoring cases.
     * @param name the name of the RecurrenceType enum object
     * @return the corresponding RecurrenceType enum object
     */
    public static RecurrenceType valueOfIgnoreCase(String name) {
        for (RecurrenceType type : RecurrenceType.values()) {
            if (type.toString().equalsIgnoreCase(name))
                return type;
        }
        
        throw new IllegalArgumentException("Unknown recurrence type: " + name);
    }
}
```
###### \java\seedu\savvytasker\storage\XmlAdaptedAliasSymbol.java
``` java
package seedu.savvytasker.storage;

import javax.xml.bind.annotation.XmlElement;

import seedu.savvytasker.commons.exceptions.IllegalValueException;
import seedu.savvytasker.model.alias.AliasSymbol;

public class XmlAdaptedAliasSymbol {

    @XmlElement(required = true)
    private String keyword;
    @XmlElement(required = true)
    private String representation;
    
    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedAliasSymbol() {}
    

    /**
     * Converts a given AliasSymbol into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedAliasSymbol
     */
    public XmlAdaptedAliasSymbol(AliasSymbol source) {
        keyword = source.getKeyword();
        representation = source.getRepresentation();
    }

    /**
     * Converts this jaxb-friendly adapted alias symbol object into the model's AliasSymbol object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted AliasSymbol
     */
    public AliasSymbol toModelType() throws IllegalValueException {
        return new AliasSymbol(keyword, representation);
    }
}
```
