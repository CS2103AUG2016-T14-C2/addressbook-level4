# A0138431L
###### \java\seedu\savvytasker\commons\events\storage\DataSavingLocationChangedEvent.java
``` java
/**
 * Indicates a change in location of the storage
 */
public class DataSavingLocationChangedEvent extends BaseEvent {

    public final ReadOnlySavvyTasker data;
    public final String newPath;

    public DataSavingLocationChangedEvent(ReadOnlySavvyTasker data, String newPath) {
        this.data = data;
        this.newPath = newPath;
    }

    @Override
    public String toString() {
        return "number of tasks " + data.getReadOnlyListOfTasks().size() +
                " new path " + this.newPath;
    }

}
```
###### \java\seedu\savvytasker\commons\events\ui\ShowCheatsheetEvent.java
``` java

package seedu.savvytasker.commons.events.ui;

import seedu.savvytasker.commons.events.BaseEvent;

/** Indicates cheatsheet display has been toggled */
public class ShowCheatsheetEvent extends BaseEvent {
	@Override
    public String toString() {
        return "Cheatsheet display has been toggled";
    }

}
```
###### \java\seedu\savvytasker\commons\events\ui\WeekSelectionChangedEvent.java
``` java

package seedu.savvytasker.commons.events.ui;

import seedu.savvytasker.commons.events.BaseEvent;

/** Indicates the SavvyTasker in the model has changed*/

public class WeekSelectionChangedEvent extends BaseEvent {

	 @Override
	    public String toString() {
	        return "Selected week has been changed";
	    }

}
```
###### \java\seedu\savvytasker\logic\commands\StorageAndModelRequiringCommand.java
``` java
/** 
 * Represents a command which requires the Storage class as a dependency.
 * Commands should inherit this class if they only require dependency for
 * storage and model components
*/
public abstract class StorageAndModelRequiringCommand extends Command {
    protected Storage storage;
    protected Model model;
    
    public void setStorage(Storage storage) { 
        this.storage = storage; 
    }
    
    public void setModel(Model model) {
        this.model = model;
    }
}
```
###### \java\seedu\savvytasker\logic\commands\StorageCommand.java
``` java
/**
 * Changes the storage location of Savvy Tasker
 */
public class StorageCommand extends StorageAndModelRequiringCommand {

    public final String path;

    public static final String COMMAND_WORD = "storage";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Sets the storage path to the path specified.\n"
            + "Parameters: PATH\n"
            + "Example: " + COMMAND_WORD + " data/savvytasker.xml";

    public static final String MESSAGE_CHANGE_LOCATION_SUCCESS = "Changed storage location to: %1$s";
    public static final String MESSAGE_CHANGE_LOCATION_FAILED = "Failed to change storage location to: %1$s";

    public StorageCommand(String path) {
        this.path = path;
    }

    @Override
    public CommandResult execute() {
        if (storage.setSavvyTaskerFilePath(path)) {
            ReadOnlySavvyTasker savvyTasker = model.getSavvyTasker();
            EventsCenter.getInstance().post(new DataSavingLocationChangedEvent(savvyTasker, path));
            return new CommandResult(String.format(MESSAGE_CHANGE_LOCATION_SUCCESS, path));
        } else {
            return new CommandResult(String.format(MESSAGE_CHANGE_LOCATION_FAILED, path));
        }
    }
    
```
###### \java\seedu\savvytasker\logic\LogicManager.java
``` java

    @Override
    public ObservableList<ReadOnlyTask> getFilteredFloatingTasks() {
        return model.getFilteredFloatingTasks();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredDailyTasks(int i, Date date) {
        return model.getFilteredDailyTasks(i, date);
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredUpcomingTasks(Date date) {
        return model.getFilteredUpcomingTasks(date);
    }
```
###### \java\seedu\savvytasker\logic\parser\TaskFieldParser.java
``` java
    public String parsefilePath(String filePathText) throws ParseException {
        if (filePathText == null) {
            return null;
        }
        return filePathText.trim();
    }
    
    public String parsefileName(String fileNameText) throws ParseException {
        if (fileNameText == null) {
            return null;
        }
        return fileNameText.trim();
    }
```
###### \java\seedu\savvytasker\MainApp.java
``` java
    @Subscribe
    public void handleSavvyTaskerSaveLocationChangedEvent(DataSavingLocationChangedEvent dslce) {
        try {
            String configPath = getApplicationParameter("config");
            if(configPath == null) {
                configPath = Config.DEFAULT_CONFIG_FILE;
            }
            config.setSavvyTaskerFilePath(dslce.newPath);
            ConfigUtil.saveConfig(config, configPath);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
    }
```
###### \java\seedu\savvytasker\model\Model.java
``` java

    /** Returns the filtered task list of floating task as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
	UnmodifiableObservableList<ReadOnlyTask> getFilteredFloatingTasks();

    /** Returns the filtered task list of daily task as an {@code UnmodifiableObservableList<ReadOnlyTask>} 
     * as of expected date */
	UnmodifiableObservableList<ReadOnlyTask> getFilteredDailyTasks(int dayOfWeek, Date date);

    /** Returns the filtered task list of upcoming task as an {@code UnmodifiableObservableList<ReadOnlyTask>} 
     * as of expected date */
	UnmodifiableObservableList<ReadOnlyTask> getFilteredUpcomingTasks(Date date);

    /** Updates the filter of the filtered task list to show all floating tasks */
    void updateFilteredListToShowFloating();
    
    /** Updates the filter of the filtered task list to show all tasks of the selected week*/
    void updateFilteredListToShowDaily(int i);

    /** Updates the filter of the filtered task list to show all upcoming tasks after the selected week*/
    void updateFilteredListToShowUpcoming();
	
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
	private final SavvyTasker savvyTasker;
	private final FilteredList<Task> filteredTasks;
	private final SortedList<Task> sortedAndFilteredTasks;
	private final FilteredList<Task> filteredFloatingTasks;
	private final SortedList<Task> sortedAndFilteredFloatingTasks;
	private final FilteredList<Task> filteredDay1Tasks;
	private final SortedList<Task> sortedAndFilteredDay1Tasks;
	private final FilteredList<Task> filteredDay2Tasks;
	private final SortedList<Task> sortedAndFilteredDay2Tasks;
	private final FilteredList<Task> filteredDay3Tasks;
	private final SortedList<Task> sortedAndFilteredDay3Tasks;
	private final FilteredList<Task> filteredDay4Tasks;
	private final SortedList<Task> sortedAndFilteredDay4Tasks;
	private final FilteredList<Task> filteredDay5Tasks;
	private final SortedList<Task> sortedAndFilteredDay5Tasks;
	private final FilteredList<Task> filteredDay6Tasks;
	private final SortedList<Task> sortedAndFilteredDay6Tasks;
	private final FilteredList<Task> filteredDay7Tasks;
	private final SortedList<Task> sortedAndFilteredDay7Tasks;
	private final FilteredList<Task> filteredUpcomingTasks;
	private final SortedList<Task> sortedAndFilteredUpcomingTasks;

	/**
	 * Initializes a ModelManager with the given SavvyTasker
	 * and its variables should not be null
	 */
	public ModelManager(SavvyTasker src) {
		super();
		assert src != null;

		logger.fine("Initializing with savvy tasker: " + src);

		savvyTasker = new SavvyTasker(src);
		filteredTasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredTasks = new SortedList<>(filteredTasks, new TaskSortedByDefault());

		filteredFloatingTasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredFloatingTasks = new SortedList<>(filteredFloatingTasks, new TaskSortedByDefault());

		filteredDay1Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay1Tasks = new SortedList<>(filteredDay1Tasks, new TaskSortedByDefault());
		filteredDay2Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay2Tasks = new SortedList<>(filteredDay2Tasks, new TaskSortedByDefault());
		filteredDay3Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay3Tasks = new SortedList<>(filteredDay3Tasks, new TaskSortedByDefault());
		filteredDay4Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay4Tasks = new SortedList<>(filteredDay4Tasks, new TaskSortedByDefault());
		filteredDay5Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay5Tasks = new SortedList<>(filteredDay5Tasks, new TaskSortedByDefault());
		filteredDay6Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay6Tasks = new SortedList<>(filteredDay6Tasks, new TaskSortedByDefault());
		filteredDay7Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay7Tasks = new SortedList<>(filteredDay7Tasks, new TaskSortedByDefault());

		filteredUpcomingTasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredUpcomingTasks = new SortedList<>(filteredUpcomingTasks, new TaskSortedByDefault());

		updateFilteredListToShowActive(); // shows only active tasks on start
	}

	public ModelManager() {
		this(new SavvyTasker());
	}

	public ModelManager(ReadOnlySavvyTasker initialData) {
		savvyTasker = new SavvyTasker(initialData);
		filteredTasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredTasks = new SortedList<>(filteredTasks, new TaskSortedByDefault());

		filteredFloatingTasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredFloatingTasks = new SortedList<>(filteredFloatingTasks, new TaskSortedByDefault());

		filteredDay1Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay1Tasks = new SortedList<>(filteredDay1Tasks, new TaskSortedByDefault());
		filteredDay2Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay2Tasks = new SortedList<>(filteredDay2Tasks, new TaskSortedByDefault());
		filteredDay3Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay3Tasks = new SortedList<>(filteredDay3Tasks, new TaskSortedByDefault());
		filteredDay4Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay4Tasks = new SortedList<>(filteredDay4Tasks, new TaskSortedByDefault());
		filteredDay5Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay5Tasks = new SortedList<>(filteredDay5Tasks, new TaskSortedByDefault());
		filteredDay6Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay6Tasks = new SortedList<>(filteredDay6Tasks, new TaskSortedByDefault());
		filteredDay7Tasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredDay7Tasks = new SortedList<>(filteredDay7Tasks, new TaskSortedByDefault());

		filteredUpcomingTasks = new FilteredList<>(savvyTasker.getTasks());
		sortedAndFilteredUpcomingTasks = new SortedList<>(filteredUpcomingTasks, new TaskSortedByDefault());

		updateFilteredListToShowActive(); // shows only active tasks on start
	}
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
	/**
	 * Qualifier for checking if {@link Task} is an overdue task
	 *
	 * A overdue task is a deadline or event task with end dateTime after current dateTime
	 * 
	 * @return true if the task is overdue
	 * 
	 */
	private class TaskIsOverdueQualifier implements Qualifier {

		@Override
		public boolean run(ReadOnlyTask task) {

			Date today = new Date();

			boolean isOverdue = false;

			if (task.getEndDateTime() != null) {

				Date endDateTime = task.getEndDateTime();

				if (endDateTime.compareTo(today)<0 && task.isArchived() == false) {

					isOverdue = true;
				}

			}

			return isOverdue;

		}

		@Override
		public String toString() {
			return "isOverdue=true";
		}
	}

	/**
	 * Qualifier for checking if {@link Task} is a floating task
	 *
	 * A floating task do not have start or end time
	 * 
	 * @return true if the task falls on the date specified. else return false
	 * 
	 */
	private class TaskIsFloatingQualifier implements Qualifier {

		@Override
		public boolean run(ReadOnlyTask task) {

			boolean isFloating = false;

			if(task.getStartDateTime() == null && task.getEndDateTime() == null && task.isArchived() == false) {

				isFloating = true;

			}

			return isFloating;        

		}

		@Override
		public String toString() {
			return "isFloating=true";
		}
	}

	/**
	 * Qualifier for checking if {@link Task} falls on the selected date
	 *
	 * Check whether the task is on the date specified (for deadline tasks)
	 * Check whether the date specified is within the range of date the task (for event tasks)
	 * Includes task that are completed.
	 * 
	 * @return true if the task falls on the date specified. else return false
	 *
	 */
	private class TaskIsOnDateQualifier implements Qualifier {

		@Override
		public boolean run(ReadOnlyTask task) {

			Date expectedDate = onDate;

			boolean isOnDate = false;

			//Archived Task
			if(task.isArchived() == true){

				isOnDate = false;

			}
			//Deadline Task
			else if(task.getStartDateTime() == null && task.getEndDateTime() != null) {

				Date endDateTime = task.getEndDateTime();

				if (DateUtils.isSameDay(endDateTime, expectedDate)) {

					isOnDate = true;

				}	

			}
			//Event Task
			else if(task.getStartDateTime() != null && task.getEndDateTime() != null) {

				Date startDateTime = task.getStartDateTime();
				Date endDateTime = task.getEndDateTime();

				if (DateUtils.isSameDay(startDateTime, expectedDate)) {

					isOnDate = true;

				} else if (DateUtils.isSameDay(endDateTime, expectedDate)) {

					isOnDate = true;

				} else if (startDateTime.compareTo(expectedDate)<0 && expectedDate.compareTo(endDateTime)<0) {

					isOnDate = true;

				}
			}

			return isOnDate;        
		}

		@Override
		public String toString() {
			return "isOnDate=true";
		}
	}

	/**
	 * Qualifier for checking if {@link Task} task is upcoming
	 *
	 * A upcoming task is a task that will happen after the last day, 2359 of selected week
	 * 
	 * @return true if the task is a upcoming task
	 * 
	 */
	private class TaskIsUpcomingQualifier implements Qualifier {

		@Override
		public boolean run(ReadOnlyTask task) {

			Date lastDateOfExpectedWeek = firstDayOfSelectedWeek;

			//convert date object to calendar object and add 7 days, last day of the selected week
			Calendar calendarExpectedDate = Calendar.getInstance();
			calendarExpectedDate.setTime(lastDateOfExpectedWeek);
			calendarExpectedDate.add(Calendar.DAY_OF_MONTH, 7);
			calendarExpectedDate.set(Calendar.HOUR_OF_DAY,23);
			calendarExpectedDate.set(Calendar.MINUTE,59);
			calendarExpectedDate.set(Calendar.SECOND,59);

			//convert calendar object back to date object
			lastDateOfExpectedWeek = calendarExpectedDate.getTime();

			boolean isUpcoming = true;

			//Archived Task
			if(task.isArchived() == true){

				isUpcoming = false;

			}

			//Floating Task
			else if(task.getStartDateTime() == null && task.getEndDateTime() == null) {

				isUpcoming = false;

			} 
			//Deadline Task
			else if(task.getStartDateTime() == null && task.getEndDateTime() != null) {


				if (task.getEndDateTime().compareTo(lastDateOfExpectedWeek)<0) {

					isUpcoming = false;

				}	

			}
			//Event Task
			else {

				if (task.getStartDateTime().compareTo(lastDateOfExpectedWeek)<0) {

					isUpcoming = false;

				}	

			}

			return isUpcoming;
		}

		@Override
		public String toString() {
			return "isUpcoming=true";
		}
```
###### \java\seedu\savvytasker\model\task\ReadOnlyTask.java
``` java
    static final String EMPTY_FIELD = " ";

    static String DATE_PATTERN = "dd MMM yy";
 	static String TIME_PATTERN = "hh:mm a";
 	
 	// String format for deadline tasks dateTime format
 	static String DEADLINE_FORMAT = "by %1$s, %2$s";
 	
 	// String format for event tasks dateTime format
 	static String EVENT_DIFF_START_END_DATE_FORMAT = "%1$s, %2$s to %3$s, %4$s";
 	static String EVENT_SAME_START_END_DATE_FORMAT = "%1$s, %2$s to %3$s";

    static Date lastDayOfSelectedWeek = new Date();
        
    /**
	 * Generates the DateTime Format for all tasks with time.
	 * 
	 * @param task the task to have its DateTime Format generated
	 * 
	 * @return DateTime Format (e.g. (31 Oct 16, 10:00PM)
	 **/
	default String generateDateTime(Date start, Date end) {
		String dateTimeFormat;
		//Floating Task
		if(start == null && end == null) {
			dateTimeFormat = EMPTY_FIELD;
		} 
		//Deadline Task
		else if(start == null && end != null) {
			dateTimeFormat = generateDeadlineDateTime(end);
		//Event Task
		}else {
			dateTimeFormat = generateEventDateTime(start, end);
		}		
		
		return dateTimeFormat;
		
	}
	
	/**
	 * Generates the dateTimeFormat for deadline tasks
	 * 
	 * @param task the task to have its dateTimeFormat generated
	 * 
	 * @return dateTimeFormat (e.g. 30 Oct 16, 10:00PM)
	 */
	default String generateDeadlineDateTime(Date end) {
		
		String dateTimeFormat;
		
		SimpleDateFormat dateFormatter = new SimpleDateFormat(DATE_PATTERN);
		SimpleDateFormat timeFormatter = new SimpleDateFormat(TIME_PATTERN);
		
		String taskEndDateFormat = dateFormatter.format(end.getTime());
		String taskEndTimeFormat = timeFormatter.format(end.getTime());
		
		dateTimeFormat = String.format(DEADLINE_FORMAT, taskEndDateFormat, taskEndTimeFormat);
				
		return dateTimeFormat;
		
	}
	
	/**
	 * Generates the dateTimeFormat for ranged tasks
	 * 
	 * @param task the task to have its dateTimeFormat generated
	 * 
	 * @return dateTimeFormat (e.g. 30 Oct 16, 8:00AM to 9:00PM)
	 */
	default String generateEventDateTime(Date start, Date end) {
		
		String dateTimeFormat;
		
		SimpleDateFormat dateFormatter = new SimpleDateFormat(DATE_PATTERN);
		SimpleDateFormat timeFormatter = new SimpleDateFormat(TIME_PATTERN);
		
		String taskStartDateFormat = dateFormatter.format(start.getTime());
		String taskStartTimeFormat = timeFormatter.format(start.getTime());
		
		String taskEndDateFormat = dateFormatter.format(end.getTime());
		String taskEndTimeFormat = timeFormatter.format(end.getTime());
		
		if(DateUtils.isSameDay(start, end) == false) {
			
			dateTimeFormat = String.format(EVENT_DIFF_START_END_DATE_FORMAT, taskStartDateFormat, taskStartTimeFormat, taskEndDateFormat, taskEndTimeFormat);
		
		} else {

			dateTimeFormat = String.format(EVENT_SAME_START_END_DATE_FORMAT, taskEndDateFormat, taskStartTimeFormat, taskEndTimeFormat);
				
		}

		return dateTimeFormat;
		
	}
}
```
###### \java\seedu\savvytasker\storage\ConfigStorage.java
``` java
package seedu.savvytasker.storage;

import java.io.IOException;
import java.util.Optional;

import seedu.savvytasker.commons.core.Config;
import seedu.savvytasker.commons.exceptions.DataConversionException;

/**
 * Represents a storage for {@link seedu.savvytasker.commons.core.Config}.
 */
public interface ConfigStorage {
    /**
     * Returns Config data from storage.
     *   Returns {@code Optional.empty()} if storage file is not found.
     * @throws DataConversionException if the data in storage is not in the expected format.
     * @throws IOException if there was any problem when reading from the storage.
     */
    Optional<Config> readConfigFile() throws DataConversionException, IOException;

    /**
     * Saves the given {@link seedu.savvytasker.commons.core.Config} to the storage.
     * @param config cannot be null.
     * @throws IOException if there was any problem writing to the file.
     */
    void saveConfigFile(Config config) throws IOException;
    
}
```
###### \java\seedu\savvytasker\storage\JsonConfigStorage.java
``` java

package seedu.savvytasker.storage;

import java.io.File;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.savvytasker.commons.core.Config;
import seedu.savvytasker.commons.core.LogsCenter;
import seedu.savvytasker.commons.exceptions.DataConversionException;
import seedu.savvytasker.commons.util.FileUtil;

/**
 * A class to access Config stored in the hard disk as a json file
 */
public class JsonConfigStorage implements ConfigStorage {

    private static final Logger logger = LogsCenter.getLogger(JsonConfigStorage.class);
    
    private String filePath;
    
    public JsonConfigStorage(String filePath) {
    	
        this.filePath = filePath;
    }
    
    @Override
    public Optional<Config> readConfigFile() throws DataConversionException, IOException {
    	
        return readConfig(filePath);
    }

    @Override
    public void saveConfigFile(Config config) throws IOException {
    	
        saveConfig(config, filePath);
    }
    
    /**
     * Similar to {@link #readConfigFile()}
     * @param configFilePath location of the data. Cannot be null.
     * @throws DataConversionException if the file format is not as expected.
     */
    public Optional<Config> readConfig(String configFilePath) throws DataConversionException {
    	
        assert configFilePath != null;

        File configFile = new File(configFilePath);

        if (!configFile.exists()) {
        	
            logger.info("Config file "  + configFile + " not found");
            
            return Optional.empty();
            
        }

        Config config;

        try {
            
        	config = FileUtil.deserializeObjectFromJsonFile(configFile, Config.class);
        	
        } catch (IOException e) {
        	
            logger.warning("Error reading from config file " + configFile + ": " + e);
            
            throw new DataConversionException(e);
            
        }

        return Optional.of(config);
    }

    /**
     * Similar to {@link #saveConfigFile(Config)}
     * @param configFilePath location of the data. Cannot be null.
     */
    private void saveConfig(Config config, String configFilePath) throws IOException {
        
    	assert config != null;
        assert configFilePath != null;
        assert !configFilePath.isEmpty();

        FileUtil.serializeObjectToJsonFile(new File(configFilePath), config);
    }

}
```
###### \java\seedu\savvytasker\storage\StorageManager.java
``` java
    @Override
    @Subscribe
    public void handleSavvyTaskerSaveLocationChangedEvent(DataSavingLocationChangedEvent dslce) {
        logger.info(LogsCenter.getEventHandlingLogMessage(dslce, "Local storage location changed."));
        try {
            saveSavvyTasker(dslce.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }
```
###### \java\seedu\savvytasker\ui\CommandBox.java
``` java
package seedu.savvytasker.ui;

import java.io.File;
import java.util.Calendar;
import java.util.Date;
import java.util.Stack;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.SplitPane;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;
import seedu.savvytasker.commons.core.LogsCenter;
import seedu.savvytasker.commons.events.model.SavvyTaskerChangedEvent;
import seedu.savvytasker.commons.events.ui.IncorrectCommandAttemptedEvent;
import seedu.savvytasker.commons.events.ui.ShowCheatsheetEvent;
import seedu.savvytasker.commons.events.ui.WeekSelectionChangedEvent;
import seedu.savvytasker.commons.util.FxViewUtil;
import seedu.savvytasker.logic.Logic;
import seedu.savvytasker.logic.commands.CommandResult;

public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;
    String previousCommandTest;
	private Date date = new Date();
	private static int DAYS_OF_WEEK = 7;	

    private final String UNDO_COMMAND = "undo";
    private final String REDO_COMMAND = "redo";
    private final String HELP_COMMAND = "help";
    private final String EXIT_COMMAND = "exit";
    private final String LIST_COMMAND = "list";
    private final String LIST_ARCHIVED_COMMAND = "list archived";
    private final String LIST_PRIORITY_COMMAND = "list priorityLevel";
    private final String LIST_ALIAS_COMMAND = "list alias";
    private final String CLEAR_COMMAND = "clear";
    private final String STORAGE_COMMAND = "storage .";
    
	KeyCombination saveKey = new KeyCodeCombination(KeyCode.S, KeyCombination.META_DOWN);
	KeyCombination undoKey = new KeyCodeCombination(KeyCode.Z, KeyCombination.META_DOWN);
	KeyCombination redoKey = new KeyCodeCombination(KeyCode.Y, KeyCombination.META_DOWN);
	KeyCombination helpKey = new KeyCodeCombination(KeyCode.H, KeyCombination.META_DOWN);
	KeyCombination exitKey = new KeyCodeCombination(KeyCode.Q, KeyCombination.META_DOWN);
	KeyCombination listKey = new KeyCodeCombination(KeyCode.L, KeyCombination.META_DOWN);
	KeyCombination listArchivedKey = new KeyCodeCombination(KeyCode.A, KeyCombination.META_DOWN);
	KeyCombination listPriorityKey = new KeyCodeCombination(KeyCode.P, KeyCombination.META_DOWN);
	KeyCombination listAliasKey = new KeyCodeCombination(KeyCode.I, KeyCombination.META_DOWN);
	KeyCombination clearKey = new KeyCodeCombination(KeyCode.D, KeyCombination.META_DOWN);
	KeyCombination leftKey = new KeyCodeCombination(KeyCode.LEFT, KeyCombination.META_DOWN);
	KeyCombination rightKey = new KeyCodeCombination(KeyCode.RIGHT, KeyCombination.META_DOWN);
    
    // stack to store commands history
 	private static Stack<String> COMMAND_HISTORY_STACK = new Stack<String>();
 	private static Stack<String> COMMAND_FUTURE_STACK = new Stack<String>();

    private Logic logic;

    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder,
            ResultDisplay resultDisplay, Logic logic) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultDisplay, logic);
        commandBox.addToPlaceholder();
        return commandBox;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }


    @FXML
    private void handleCommandInputChanged() {
        //Take a copy of the command text
        previousCommandTest = commandTextField.getText();
        
        COMMAND_HISTORY_STACK.push(previousCommandTest);
        /* We assume the command is correct. If it is incorrect, the command box will be changed accordingly
         * in the event handling code {@link #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }


    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
        commandTextField.setText("");
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event,"Invalid command: " + previousCommandTest));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText("");
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }

	public Node getCommandTextField() {
		return commandTextField;
	}
	
	//==================== Keyboard Shortcuts Code =================================================================
    /**
	 * Key pressed handler for text box.
	 * 
	 * @param keyEvent key event for the button that is being pressed.
	 */
	public void commandTextFieldOnKeyPressedHandler(KeyEvent keyEvent) {
		
		String userInput = commandTextField.getText().trim();
		
		try {

			KeyCode keyCode = keyEvent.getCode();

			if(saveKey.match(keyEvent)) {
		        
				processSave();
		        
			}else if (keyCode == KeyCode.ESCAPE) {
				
				showCheatsheet();
				
			} else if (keyCode == KeyCode.UP) {

				processUp(userInput);
				
			} else if (keyCode == KeyCode.DOWN) {
				
				processDown(userInput);
				
			} else if (leftKey.match(keyEvent)) {

				processDate(-1);
				
			} else if (rightKey.match(keyEvent)) {
				
				processDate(1);
				
			} else if (undoKey.match(keyEvent)) {
					
				executeCommand(UNDO_COMMAND);
					
			} else if (redoKey.match(keyEvent)) {
				
				executeCommand(REDO_COMMAND);
				
			} else if (helpKey.match(keyEvent)) {
				
				executeCommand(HELP_COMMAND);
				
			} else if (exitKey.match(keyEvent)) {
				
				executeCommand(EXIT_COMMAND);
				
			} else if (listKey.match(keyEvent)) {
				
				executeCommand(LIST_COMMAND);
				
			} else if (listArchivedKey.match(keyEvent)) {
				
				executeCommand(LIST_ARCHIVED_COMMAND);
				
			} else if (listPriorityKey.match(keyEvent)) {
				
				executeCommand(LIST_PRIORITY_COMMAND);
				
			} else if (listAliasKey.match(keyEvent)) {
				
				executeCommand(LIST_ALIAS_COMMAND);
				
			} else if (clearKey.match(keyEvent)) {
				
				executeCommand(CLEAR_COMMAND);
				
			}
			
		} catch (IllegalArgumentException e) {

			commandTextField.setText("");

	        COMMAND_HISTORY_STACK.add(userInput);
			
			this.logger.info("Illegal Argument has been entered.");
			
		} catch (Exception e) {
			
			e.printStackTrace();
			commandTextField.setText("");
			
			this.logger.info("Illegal Argument has been entered.");
			
		}
		
	}
	
	/**
	 * Process the event that occurs after the user presses the ctrl-S button.
	 * 
	 * @param userInput the command keyed in by the user.
	 */
	public void processSave() {
		
		//Execute the save command
		DirectoryChooser directoryChooser = new DirectoryChooser();
		File selectedFile = directoryChooser.showDialog(primaryStage);
		String filepath = selectedFile.getAbsolutePath();
		executeCommand(STORAGE_COMMAND + filepath + "/savvytasker.xml");
	    
	}
	
	/**
	 * Process the event that occurs after the user presses the [UP] button.
	 * 
	 * @param userInput the command keyed in by the user.
	 */
	public void processUp(String userInput) {

		if (!COMMAND_HISTORY_STACK.isEmpty()) {
			
			String previousCommand = COMMAND_HISTORY_STACK.pop();
			
			if (!userInput.equals("")) {
				
				COMMAND_FUTURE_STACK.push(userInput);
				
			}
			
			commandTextField.setText(previousCommand);
			
		}
		
		commandTextField.positionCaret(commandTextField.getText().length());
		
	}
	
	/**
	 * Process the event that occurs after the user presses the down button.
	 * 
	 * @param userInput the command keyed in by the user.
	 */
	public void processDown(String userInput) {
		
		if (!COMMAND_FUTURE_STACK.isEmpty()) {
			
			String nextCommand = COMMAND_FUTURE_STACK.pop();
			
			COMMAND_HISTORY_STACK.push(userInput);
			commandTextField.setText(nextCommand);
			
		} else if (!userInput.equals("")) {
			
			COMMAND_HISTORY_STACK.push(userInput);
			commandTextField.setText("");
			
		}
		
		commandTextField.positionCaret(commandTextField.getText().length());
		
	}
	
	/**
	 * Process the event that occurs after the user presses the left or right button.
	 * 
	 * @param numbers of week to be added to the current selected week to be displayed in the daily task list view
	 */
	public void processDate(int numberOfWeek) {
		
		date  = addWeek(numberOfWeek, date);
		indicateWeekSelectionChanged();
	}
	
	/** Raises an event to indicate the week to be displayed has changed */
	private void indicateWeekSelectionChanged() {
		raise(new WeekSelectionChangedEvent());
	}
	
	/** Raises an event to indicate the week to be displayed has changed */
	private void showCheatsheet() {
		raise(new ShowCheatsheetEvent());
	}
	
	/**
	 * Execute commands
	 * 
	 * @param command to be executed
	 */
	public void executeCommand(String commandInput) {
		CommandResult commandResult = logic.execute(commandInput);	
		resultDisplay.postMessage(commandResult.feedbackToUser);
		logger.info("Result: " + commandResult.feedbackToUser);
	}
	
	private Date addWeek(int numberOfWeek, Date date) {
		
        //convert date object to calendar object and add 1 days
        Calendar calendarExpectedDate = Calendar.getInstance();
        calendarExpectedDate.setTime(date);
        
        calendarExpectedDate.add(Calendar.DATE, (numberOfWeek*DAYS_OF_WEEK));
			
        //convert calendar object back to date object
        date = calendarExpectedDate.getTime();
			
        return date;
    }
	
	public Date getDate() {
		return date;
	} 
}

```
###### \java\seedu\savvytasker\ui\DailyPanel.java
``` java

/**
 * Panel containing the list overdue task.
 * @author A0138431L
 * 
 */
public class DailyPanel extends UiPart {

	private static String TODAY_TITLE = "Today";
	private static String TOMORROW_TITLE = "Tomorrow";
	private static String DAY_PATTERN = "EEEE";
	private static String DATE_PATTERN = "dd MMM yy";
	private static String DAY_DATE_FORMAT = "%1$s, %2$s";

	private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
	private static final String FXML = "DailyList.fxml";
	private VBox panel;
	private AnchorPane placeHolderPane;


	@FXML 
	private TextField header;

	@FXML
	private ListView<ReadOnlyTask> taskListView;

	public DailyPanel() {
		super();
	}

	@Override
	public void setNode(Node node) {
		panel = (VBox) node;
	}

	@Override
	public String getFxmlPath() {
		return FXML;
	}

	@Override
	public void setPlaceholder(AnchorPane pane) {
		this.placeHolderPane = pane;
	}

	public static DailyPanel load(Stage primaryStage, AnchorPane DailyListPlaceholder,
			ObservableList<ReadOnlyTask> taskList, int dayOfTheWeek, Date date) {
		DailyPanel dailyPanel =
				UiPartLoader.loadUiPart(primaryStage, DailyListPlaceholder, new DailyPanel());
		dailyPanel.configure(taskList, dayOfTheWeek, date);
		return dailyPanel;
	}

	private void configure(ObservableList<ReadOnlyTask> taskList, int dayOfTheWeek, Date date) {

		String dateHeader = generateHeader(dayOfTheWeek, date);
		Date today = new Date();
		if(date == today) {
			placeHolderPane.setStyle("-fx-background-color:#FF0000");
			header.setStyle("-fx-text-fill:#FF0000");
		}
		setConnections(taskList, dateHeader);
		addToPlaceholder();
		
	}

	private void setConnections(ObservableList<ReadOnlyTask> taskList, String dateHeader) {
		header.clear();
		header.setText(dateHeader);
		taskListView.setItems(taskList);
		taskListView.setCellFactory(listView -> new TaskListViewCell());
		setEventHandlerForSelectionChangeEvent();
	}

	private void addToPlaceholder() {
		SplitPane.setResizableWithParent(placeHolderPane, false);
		placeHolderPane.getChildren().add(panel);
	}

	private void setEventHandlerForSelectionChangeEvent() {
		taskListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
			if (newValue != null) {
				logger.fine("Selection in daily task list panel changed to : '" + newValue + "'");
				raise(new TaskPanelSelectionChangedEvent(newValue));
			}
		});
	}

	public void scrollTo(int index) {
		Platform.runLater(() -> {
			taskListView.scrollTo(index);
			taskListView.getSelectionModel().clearAndSelect(index);
		});
	}

	private String generateHeader(int dayOfTheWeek, Date date) {

		SimpleDateFormat dayFormatter = new SimpleDateFormat(DAY_PATTERN);
		SimpleDateFormat dateFormatter = new SimpleDateFormat(DATE_PATTERN);

		Date today = new Date();
		Date tomorrow = new Date();
		tomorrow = addDay(1, tomorrow);
		
		String day;

		if(DateUtils.isSameDay(date, today)) {

			day = TODAY_TITLE; 
		
		} else if (DateUtils.isSameDay(date, tomorrow)) {

			day = TOMORROW_TITLE;
		
		} else {

			day = dayFormatter.format(date);

		}
		String header = String.format(DAY_DATE_FORMAT, day, dateFormatter.format(date));

		return header;
	}
	
	private Date addDay(int i, Date date) {
		
        //convert date object to calendar object and add 1 days
        Calendar calendarExpectedDate = Calendar.getInstance();
        calendarExpectedDate.setTime(date);
        
        calendarExpectedDate.add(Calendar.DATE, i);
			
        //convert calendar object back to date object
        date = calendarExpectedDate.getTime();
			
        return date;
    }

	class TaskListViewCell extends ListCell<ReadOnlyTask> {

		public TaskListViewCell() {
		}

		@Override
		protected void updateItem(ReadOnlyTask task, boolean empty) {
			super.updateItem(task, empty);

			if (empty || task == null) {
				setGraphic(null);
				setText(null);
			} else {
				setGraphic(TaskCard.load(task, 0, false).getLayout());
			}
		}
	}

}
```
###### \java\seedu\savvytasker\ui\FloatingPanel.java
``` java

/**
 * Panel containing the list floating task.
 * @author A0138431L
 * 
 */
public class FloatingPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "FloatingList.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> taskListView;

    public FloatingPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static FloatingPanel load(Stage primaryStage, AnchorPane floatingListPlaceholder,
                                       ObservableList<ReadOnlyTask> taskList) {
    	FloatingPanel floatingPanel =
                UiPartLoader.loadUiPart(primaryStage, floatingListPlaceholder, new FloatingPanel());
    	floatingPanel.configure(taskList);
        return floatingPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        taskListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in floating task list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
            taskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        public TaskListViewCell() {
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, 0, false).getLayout());
            }
        }
    }

}
```
###### \java\seedu\savvytasker\ui\MainWindow.java
``` java

package seedu.savvytasker.ui;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

import com.google.common.eventbus.Subscribe;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.MenuItem;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyCombination;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

import seedu.savvytasker.commons.core.Config;
import seedu.savvytasker.commons.core.GuiSettings;
import seedu.savvytasker.commons.core.LogsCenter;
import seedu.savvytasker.commons.events.model.SavvyTaskerChangedEvent;
import seedu.savvytasker.commons.events.ui.ExitAppRequestEvent;
import seedu.savvytasker.commons.events.ui.ShowCheatsheetEvent;
import seedu.savvytasker.commons.events.ui.WeekSelectionChangedEvent;
import seedu.savvytasker.logic.Logic;
import seedu.savvytasker.model.UserPrefs;
import seedu.savvytasker.model.task.ReadOnlyTask;

/**
 * The Main Window. Provides the basic application layout containing
 * a sorting and filtered list that display the result of the user command 
 * on the left and a week's view of the task
 * 
 * The week's view contains 4 lists, namely the floating list, 
 * days of the week list and upcoming list
 *  
 * Floating list contains task without start and end dateTime
 * Days of the week list contains task that falls on the respective day of the selected week
 * Upcoming list contains task with start date after the last day of selected week
 * 
 * @author A0138431L
 * 
 */
public class MainWindow extends UiPart {

	private static final String ICON = "/images/savvytasker-icon.png";
	private static final Image image = new Image(MainWindow.class.getResourceAsStream(ICON));
	private static final String CHEATSHEET = "/images/cheatsheet.png";
	private static final Image imageOverlay = new Image(MainWindow.class.getResourceAsStream(CHEATSHEET));
	private static final String FXML = "MainWindow.fxml";
	public static final int MIN_HEIGHT = 700;
	public static final int MIN_WIDTH = 1150;

	private Logic logic;
	Date firstDayOfSelectedWeek = new Date();
	private static int DAYS_OF_WEEK = 7;
	private boolean isShown = false;

	// Independent Ui parts residing in this Ui container
	//private BrowserPanel browserPanel;
	private TaskListPanel taskListPanel;
    private AliasSymbolListPanel aliasSymbolListPanel;
	private ResultDisplay resultDisplay;
	private StatusBarFooter statusBarFooter;
	private CommandBox commandBox;
	private Config config;
	private UserPrefs userPrefs;
	@FXML
	private FloatingPanel floatingPanel;
	@FXML
	private DailyPanel dailyPanel;
	@FXML
	private UpcomingPanel upcomingPanel;

	// Handles to elements of this Ui container
	private VBox rootLayout;
	private Scene scene;

	private String addressBookName;

	@FXML
	private AnchorPane browserPlaceholder;

	@FXML
	private AnchorPane commandBoxPlaceholder;

	@FXML
	private ImageView imageIcon;
	
	@FXML
	private ImageView cheatsheet;

    @FXML
    private AnchorPane taskListPanelPlaceholder;
    
    @FXML
    private AnchorPane aliasSymbolListPanelPlaceholder;

	@FXML
	private AnchorPane resultDisplayPlaceholder;

	@FXML
	private AnchorPane statusbarPlaceholder;

    @FXML
    private VBox listPanel;

	@FXML 
	private AnchorPane floatingPanelPlaceholder;

	@FXML 
	private AnchorPane day1PanelPlaceholder;
	@FXML 
	private AnchorPane day2PanelPlaceholder;
	@FXML 
	private AnchorPane day3PanelPlaceholder;
	@FXML 
	private AnchorPane day4PanelPlaceholder;
	@FXML 
	private AnchorPane day5PanelPlaceholder;
	@FXML 
	private AnchorPane day6PanelPlaceholder;
	@FXML 
	private AnchorPane day7PanelPlaceholder;
	
	@FXML 
	private AnchorPane upcomingPanelPlaceholder;

	public MainWindow() {
		super();
	}

	@Override
	public void setNode(Node node) {
		rootLayout = (VBox) node;
	}

	@Override
	public String getFxmlPath() {
		return FXML;
	}

	public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {

		MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
		mainWindow.configure(config.getAppTitle(), config.getSavvyTaskerListName(), config, prefs, logic);
		return mainWindow;
	}

	private void configure(String appTitle, String addressBookName, Config config, UserPrefs prefs,
			Logic logic) {

		//Set dependencies
		this.logic = logic;
		this.addressBookName = addressBookName;
		this.config = config;
		this.userPrefs = prefs;
        registerAsAnEventHandler(this);

		//Configure the UI
		setTitle(appTitle);
		setIcon(ICON);
		setWindowMinSize();
		setWindowDefaultSize(prefs);
		scene = new Scene(rootLayout);
		primaryStage.setScene(scene);

	}

	void fillInnerParts() {
		imageIcon.setImage(image);
        taskListPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getFilteredTaskList());
        aliasSymbolListPanel = AliasSymbolListPanel.load(primaryStage, getAliasSymbolPlaceholder(), logic.getAliasSymbolList());
        setDefaultView();
		resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
		statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getSavvyTaskerFilePath());
		commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
		commandBox.getCommandTextField().requestFocus();
		floatingPanel = FloatingPanel.load(primaryStage, getFloatingPanelPlaceholder(), logic.getFilteredFloatingTasks());
		loadDailyPanel();
		upcomingPanel = UpcomingPanel.load(primaryStage, getUpcomingPanelPlaceholder(), logic.getFilteredUpcomingTasks(firstDayOfSelectedWeek));
		cheatsheet.setImage(imageOverlay);
	}

	private void loadDailyPanel() {
		firstDayOfSelectedWeek = commandBox.getDate();
        for (int i = 0; i < DAYS_OF_WEEK; i++) {
            Date onDate = new Date();
            onDate.setTime(firstDayOfSelectedWeek.getTime());
            onDate = addDay(i, onDate);
            dailyPanel = DailyPanel.load(primaryStage, getDailyPanelPlaceholder(i),
                    logic.getFilteredDailyTasks(i, onDate), i, onDate);
        }
	}

	/**
     * Removes all the children in the taskPanel VBox
     * Shows the default list, which is the list of tasks
     */
    private void setDefaultView() {
        getListPanel().getChildren().remove(getAliasSymbolPlaceholder());
        getListPanel().getChildren().remove(getTaskListPlaceholder());
        getListPanel().getChildren().add(getTaskListPlaceholder());
    }
    
    /**
     * Set to true to show the list of tasks. Set to false to show the list of alias
     * @param isShown
     */
    public void showTaskList(boolean isShown) {
        getListPanel().getChildren().remove(getAliasSymbolPlaceholder());
        getListPanel().getChildren().remove(getTaskListPlaceholder());
        if (isShown) {
            getListPanel().getChildren().add(getTaskListPlaceholder());
        } else {
            getListPanel().getChildren().add(getAliasSymbolPlaceholder());
        }
    }
    
    private VBox getListPanel() {
        return listPanel;
    }

    private VBox getRootLayout() {
        return rootLayout;
    }
    
	private AnchorPane getCommandBoxPlaceholder() {
		return commandBoxPlaceholder;
	}

	private AnchorPane getStatusbarPlaceholder() {
		return statusbarPlaceholder;
	}

	private AnchorPane getResultDisplayPlaceholder() {
		return resultDisplayPlaceholder;
	}

    public AnchorPane getTaskListPlaceholder() {
        return taskListPanelPlaceholder;
    }
    
    public AnchorPane getAliasSymbolPlaceholder() {
        return aliasSymbolListPanelPlaceholder;
    }

	private AnchorPane getFloatingPanelPlaceholder() {
		return floatingPanelPlaceholder;
	}

	private AnchorPane getDailyPanelPlaceholder(int index) {

		switch(index) {

		case 0: 
			
			return day1PanelPlaceholder;

		case 1: 

			return day2PanelPlaceholder;

		case 2: 

			return day3PanelPlaceholder;

		case 3: 

			return day4PanelPlaceholder;

		case 4: 

			return day5PanelPlaceholder;

		case 5: 

			return day6PanelPlaceholder;
		
		case 6: 
		default:

			return day7PanelPlaceholder;

		}

    }

    private AnchorPane getUpcomingPanelPlaceholder() {
        return upcomingPanelPlaceholder;
    }

    private Date addDay(int i, Date date) {
			
        //convert date object to calendar object and add 1 days
        Calendar calendarExpectedDate = Calendar.getInstance();
        calendarExpectedDate.setTime(date);
        
        calendarExpectedDate.add(Calendar.DATE, i);
			
        //convert calendar object back to date object
        date = calendarExpectedDate.getTime();
			
        return date;
    }
		
    public void hide() {
        primaryStage.hide();
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

	/**
	 * Sets the default size based on user preferences.
	 */
	protected void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
    * Returns the current size and the position of the main Window.
    */
    public GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(),
            (int) primaryStage.getX(), (int) primaryStage.getY());
    }

    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.show();
    }
		
	public void hideHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.hide();
    }

	public void show() {
		primaryStage.show();
    }

    /**
    * Closes the application.
    */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }
    
    public AliasSymbolListPanel getAliasSymbolListPanel() {
        return this.aliasSymbolListPanel;
    }

    public TaskListPanel getTaskListPanel() {
        return this.taskListPanel;
    }

	public void loadPersonPage(ReadOnlyTask task) {
        //feature removed
		//browserPanel.loadPersonPage(task);
	}

	public void releaseResources() {
        //feature removed
		//browserPanel.freeResources();
    }

    @Subscribe
    public void handleSavvyTaskerChangedEvent(SavvyTaskerChangedEvent stce) {
        loadDailyPanel();
    }
    
    @Subscribe
    public void handleWeekSelectionChangedEvent(WeekSelectionChangedEvent stce) {
        loadDailyPanel();
    }
    
    @Subscribe
    public void handleCheatsheetDisplayToggledEvent(ShowCheatsheetEvent stce) {
    	
    	if(isShown == false) {
    		cheatsheet.setVisible(true);
    		isShown = true;
    	} else {
    		cheatsheet.setVisible(false);
    		isShown = false;
    	}
    }
		
}
```
###### \java\seedu\savvytasker\ui\StatusBarFooter.java
``` java
    @Subscribe
    public void handleSavvyTaskerSaveLocationChangedEvent(DataSavingLocationChangedEvent dslce) {
        setSaveLocation(dslce.newPath);
    }
```
###### \java\seedu\savvytasker\ui\TaskCard.java
``` java

package seedu.savvytasker.ui;

import java.util.Date;

import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import seedu.savvytasker.model.task.ReadOnlyTask;

public class TaskCard extends UiPart{

    private static final String FXML = "TaskListCard.fxml";
    
    private static final String ICON = "/images/overdue.png";
	private static final Image OVERDUE_IMAGE = new Image(MainWindow.class.getResourceAsStream(ICON));
	
    public static final String LOW_PRIORITY_BACKGROUND = "-fx-background-color:#CEFFDC";
    public static final String MEDIUM_PRIORITY_BACKGROUND = "-fx-background-color:#FFFED8";
    public static final String HIGH_PRIORITY_BACKGROUND = "-fx-background-color:#FF8180";
        
    @FXML
    private HBox cardPane;
    @FXML
    private Label taskName;
    @FXML
    private Label id;
    @FXML
    private Label details;
    @FXML
	private ImageView overdueIcon;

    private boolean isShowingIndex;
    private ReadOnlyTask task;
    private int displayedIndex;
    
    public TaskCard(boolean isShowingIndex){
        this.isShowingIndex = isShowingIndex;
    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex, boolean isShowingIndex){
        TaskCard card = new TaskCard(isShowingIndex);
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        
    	taskName.setText(task.getTaskName());
    	if (isShowingIndex) {
            id.setText(displayedIndex + ". ");
    	}
        details.setText(task.getTextForUi());
        setCardBackground();
		setOverdue();
		
    }

    public HBox getLayout() {
        return cardPane;
    }
    
    private void setOverdue() {
    	
    	Date today = new Date();
    	
		if (task.getEndDateTime() != null) {

			Date endDateTime = task.getEndDateTime();

			if (endDateTime.compareTo(today)<0 && task.isArchived() == false) {

				overdueIcon.setImage(OVERDUE_IMAGE);
			}
		}
    	
    }
    private void setCardBackground() {
    	
        if (task.getPriority().toString().equals("High")) {
        	
            cardPane.setStyle(HIGH_PRIORITY_BACKGROUND);
        
        } else if (task.getPriority().toString().equals("Medium"))  {
         
        	cardPane.setStyle(MEDIUM_PRIORITY_BACKGROUND);
       
        } else if (task.getPriority().toString().equals("Low"))  {
        
        	cardPane.setStyle(LOW_PRIORITY_BACKGROUND);
      
        }
        
    }
    
    
    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \java\seedu\savvytasker\ui\UpcomingPanel.java
``` java

/**
* Panel containing the list overdue task.
* @author A0138431L
* 
*/
public class UpcomingPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "UpcomingList.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> taskListView;

    public UpcomingPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static UpcomingPanel load(Stage primaryStage, AnchorPane UpcomingListPlaceholder,
                                       ObservableList<ReadOnlyTask> taskList) {
    	UpcomingPanel upcomingPanel =
                UiPartLoader.loadUiPart(primaryStage, UpcomingListPlaceholder, new UpcomingPanel());
    	upcomingPanel.configure(taskList);
        return upcomingPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        taskListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in upcoming task list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
            taskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        public TaskListViewCell() {
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, 0, false).getLayout());
            }
        }
    }

}
```
###### \resources\view\DarkTheme.css
``` css
.background {
    -fx-background-color: derive(#1d1d1d, 20%);
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #555555;
    -fx-opacity: 0.9;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 32pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.text-field {
    -fx-font-size: 12pt;
    -fx-font-family: "Segoe UI Semibold";
}

.tab-pane {
    -fx-padding: 0 0 0 1;
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.table-view {
    -fx-base: #1d1d1d;
    -fx-control-inner-background: #1d1d1d;
    -fx-background-color: #1d1d1d;
    -fx-table-cell-border-color: transparent;
    -fx-table-header-border-color: transparent;
    -fx-padding: 5;
}

.table-view .column-header-background {
    -fx-background-color: transparent;
}

.table-view .column-header, .table-view .filler {
    -fx-size: 35;
    -fx-border-width: 0 0 1 0;
    -fx-background-color: transparent;
    -fx-border-color:
        transparent
        transparent
        derive(-fx-base, 80%)
        transparent;
    -fx-border-insets: 0 10 1 0;
}

.table-view .column-header .label {
    -fx-font-size: 20pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-alignment: center-left;
    -fx-opacity: 1;
}

.table-view:focused .table-row-cell:filled:focused:selected {
    -fx-background-color: -fx-focus-color;
}

.split-pane:horizontal .split-pane-divider {
    -fx-border-color: transparent #1d1d1d transparent #1d1d1d;
    -fx-background-color: transparent, derive(#1d1d1d, 10%);
}

.split-pane {
    -fx-border-radius: 1;
    -fx-border-width: 1;
    -fx-background-color: derive(#1d1d1d, 20%);
}

.list-cell {
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 0 0 0 0;
}

.list-cell .label {
    -fx-text-fill: #010504;
    -fx-font-family:'Helvetica Condensed'; 
}

.cell_big_label {
    -fx-font-size: 12px;
    -fx-text-fill: #010504;
    -fx-font-family:'Helvetica Condensed'; 
}

.cell_small_label {
    -fx-font-size: 10px;
    -fx-text-fill: #696969;
}

.anchor-pane {
     -fx-background-color: derive(#1d1d1d, 20%);
}

.anchor-pane-with-border {
     -fx-background-color: derive(#1d1d1d, 20%);
     -fx-border-color: derive(#1d1d1d, 10%);
     -fx-border-top-width: 1px;
}

.status-bar {
    -fx-background-color: derive(#1d1d1d, 20%);
    -fx-text-fill: black;
}

.result-display {
    -fx-background-color: transparent;
}

.result-display .content {
    -fx-background-color: #383838;
}

.result-display .label {
    -fx-text-fill: black !important;
}

.status-bar .label {
    -fx-text-fill: white;
}

.status-bar-with-border {
    -fx-background-color: derive(#1d1d1d, 30%);
    -fx-border-color: derive(#1d1d1d, 25%);
    -fx-border-width: 1px;
}

.status-bar-with-border .label {
    -fx-text-fill: white;
}

.grid-pane {
    -fx-background-color: derive(#1d1d1d, 30%);
    -fx-border-color: derive(#1d1d1d, 30%);
    -fx-border-width: 1px;
}

.grid-pane .anchor-pane {
    -fx-background-color: derive(#1d1d1d, 30%);
}

.context-menu {
    -fx-background-color: derive(#1d1d1d, 50%);
}

.context-menu .label {
    -fx-text-fill: white;
}

.menu-bar {
    -fx-background-color: derive(#1d1d1d, 20%);
}

.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 0.9;
}

.menu .left-container {
    -fx-background-color: black;
}

/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #1d1d1d;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #1d1d1d;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.label.content {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: derive(#1d1d1d, 25%);
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 18px;
    -fx-font-style: italic;
    -fx-fill: white;
    -fx-text-fill: white;
}

.scroll-bar .thumb {
    -fx-background-color: derive(#1d1d1d, 50%);
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

.cardPane {
    -fx-border-color: #ffffff;
    -fx-border-radius: 5px;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#filterField, #personListPanel, #personWebpage {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}

#taskListView {
	-fx-background-color: transparent;
}

#header {
	fx-font-size: 11px;
    -fx-text-fill: #000000;
    -fx-font-family:'Helvetica Condensed'; 
}

/*------------------------------------------ FloatingPanel Styling ------------------------------------------*/

.floating-scrollpane, .floating-panel {
	-fx-background-color:#ACEDFF;
	-fx-border-radius: 15px;
	-fx-font-size: 14px;
    -fx-text-fill: #000000;
    -fx-font-family:'Helvetica Bold'; 
}

.floating-scrollpane {
	-fx-border-radius: 15px;
}

.floating-scrollpane > .scroll-bar:horizontal .thumb,
.floating-scrollpane > .scroll-bar:vertical .thumb {
	-fx-background-color:#406C7F;
}

.floating-panel .title, .floating-panel .taskname {
	-fx-text-fill:#000000;
}

.floating-panel .subtitle, .floating-panel .timestamp {
	-fx-text-fill:#5997BS2;
}

/*------------------------------------------ DailyPanel Styling ------------------------------------------*/

.daily-scrollpane, .daily-panel {
	-fx-background-color:#99D3FF;
	-fx-border-radius: 15px;
	-fx-font-size: 14px;
    -fx-text-fill: #000000;
    -fx-font-family:'Helvetica Bold'; 
}

.daily-scrollpane > .scroll-bar:horizontal .thumb,
.daily-scrollpane > .scroll-bar:vertical .thumb {
	-fx-background-color:#7E7E45;
}

.daily-panel .title, .daily-panel .taskname {
	-fx-text-fill:#5D5D33;
}

.daily-panel .subtitle, .daily-panel .timestamp {
	-fx-text-fill:#B2B262;
}

/*------------------------------------------ UpcomingPanel Styling ------------------------------------------*/
.upcoming-scrollpane, .upcoming-panel {
	-fx-background-color:#D1E0FF;
	-fx-border-radius: 15px;
	-fx-font-size: 14px;
    -fx-text-fill: #000000;
    -fx-font-family:'Helvetica Bold'; 
}

.upcoming-scrollpane > .scroll-bar:horizontal .thumb,
.upcoming-scrollpane > .scroll-bar:vertical .thumb {
	-fx-background-color:#657E47;
}

.upcoming-panel .check-box > .box {
	-fx-border-color:#657E47;
}

.upcoming-panel .check-box {
	-fx-font-family:'Helvetica';
	-fx-text-fill:#485A33;
	-fx-font-size:10;
	-fx-font-weight:bold;
}

.upcoming-panel .title, .upcoming-panel .taskname {
	-fx-text-fill:#485A33;
}

.upcoming-panel .subtitle, .upcoming-panel .timestamp {
	-fx-text-fill:#8EB264;
}

/*------------------------------------------ ArchivedPanel Styling ------------------------------------------*/

.archived-panel .title {
	-fx-font-family:'Helvetica Condensed';
	-fx-font-size:24;
	-fx-font-weight:normal;
}

.archived-panel .taskname, .archived-panel .timestamp {
	-fx-text-fill:#FFFFFF;
}
```
