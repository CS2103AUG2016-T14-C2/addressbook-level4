# A0139915W
###### \java\seedu\savvytasker\commons\events\ui\TaskPanelSelectionChangedEvent.java
``` java

/**
 * Represents a selection change in the Task List Panel
 */
public class TaskPanelSelectionChangedEvent extends BaseEvent {


    private final ReadOnlyTask newSelection;

    public TaskPanelSelectionChangedEvent(ReadOnlyTask newSelection){
        this.newSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ReadOnlyTask getNewSelection() {
        return newSelection;
    }
}
```
###### \java\seedu\savvytasker\commons\events\ui\TaskPanelSelectionChangedEvent.java
``` java

```
###### \java\seedu\savvytasker\commons\util\SmartDefaultDates.java
``` java
/**
 * Helper functions for handling dates.
 * @author A0139915W
 */

public class SmartDefaultDates {
    
    private Date startDateTime;
    private Date endDateTime;
    private final Calendar calendar;
    private final Calendar today;
    
    /**
     * 
     * @param startDateTime Starting date time
     * @param endDateTime Ending date time
     * @throws InvalidDateException If endDateTime is earlier than startDateTime
     */
    public SmartDefaultDates(InferredDate startDateTime, InferredDate endDateTime) {
        calendar = Calendar.getInstance();
        today = Calendar.getInstance();
        today.setTime(new Date());
        if (startDateTime == null && endDateTime == null) {
            // dates not being supplied, nothing to parse
        } else if (startDateTime == null && endDateTime != null) {
            // apply smart default for endDateTime only
            parseEnd(endDateTime);
        } else if (startDateTime != null && endDateTime == null) {
            // apply smart default for startDateTime only
            parseStart(startDateTime);
        } else {
            parseStartAndEnd(startDateTime, endDateTime);
        }
    }
    
    /**
     * Gets the smart default for end date
     * @param today the time now
     * @param endDateTime the end time to parse
     * @return
     */
    public Date getEnd(InferredDate endDateTime) {
        if (endDateTime == null) return null;
        calendar.setTime(endDateTime.getInferredDateTime());
        if (endDateTime.isDateInferred()) {
            // date not supplied
            // defaults to today
            calendar.set(Calendar.DATE, today.get(Calendar.DATE));
            calendar.set(Calendar.MONTH, today.get(Calendar.MONTH));
            calendar.set(Calendar.YEAR, today.get(Calendar.YEAR));
        } else if (endDateTime.isTimeInferred()) {
            // time not supplied
            // defaults to 2359
            calendar.set(Calendar.HOUR_OF_DAY, 23);
            calendar.set(Calendar.MINUTE, 59);
            calendar.set(Calendar.SECOND, 59);
        }
        return calendar.getTime();
    }
    
    /**
     * Sets the starting and ending date/time based on defaults for providing only
     * the end time
     * @param endDateTime end time supplied
     */
    private void parseEnd(InferredDate endDateTime) {
        assert endDateTime.getInferredDateTime() != null;
        Date start = new Date();
        this.endDateTime = getEnd(endDateTime);
        
        // Since only end date is supplied, the task is considered to start at 12am today
        calendar.setTime(start);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        this.startDateTime = calendar.getTime();
    }

    
    /**
     * Gets the smart default for start date
     * @param today the time now
     * @param startDateTime the start time to parse
     * @return
     */
    public Date getStart(InferredDate startDateTime) {
        if (startDateTime == null) return null;
        calendar.setTime(startDateTime.getInferredDateTime());
        if (startDateTime.isDateInferred()) {
            // date not supplied
            // defaults to today
            calendar.set(Calendar.DATE, today.get(Calendar.DATE));
            calendar.set(Calendar.MONTH, today.get(Calendar.MONTH));
            calendar.set(Calendar.YEAR, today.get(Calendar.YEAR));
        } else if (startDateTime.isTimeInferred()) {
            // time not supplied
            // defaults to 0000
            calendar.set(Calendar.HOUR_OF_DAY, 0);
            calendar.set(Calendar.MINUTE, 0);
            calendar.set(Calendar.SECOND, 0);
        }
        return calendar.getTime();
    }

    
    /**
     * Sets the starting and ending date/time based on defaults for providing only
     * the start time
     * @param startDateTime start time supplied
     */
    private void parseStart(InferredDate startDateTime) {
        assert startDateTime.getInferredDateTime() != null;
        Date end = (Date)startDateTime.getInferredDateTime().clone();
        this.startDateTime = getStart(startDateTime);
        
        // Since only the start time is supplied, the task is considered to end today 2359 on the same day as start.
        calendar.setTime(end);
        calendar.set(Calendar.HOUR_OF_DAY, 23);
        calendar.set(Calendar.MINUTE, 59);
        calendar.set(Calendar.SECOND, 59);
        this.endDateTime = calendar.getTime();
    }

    /**
     * Sets the starting and ending date/time based on defaults for providing both
     * start and end times
     * @param startDateTime start time supplied
     */
    private void parseStartAndEnd(InferredDate startDateTime, InferredDate endDateTime) {
        assert endDateTime.getInferredDateTime() != null;
        assert startDateTime.getInferredDateTime() != null;
        Date start = getStart(startDateTime);
        Date end = getEnd(endDateTime);
        this.startDateTime = start;
        this.endDateTime = end;
        if (this.startDateTime.compareTo(this.endDateTime) > 0) {
            calendar.setTime(this.endDateTime);
            calendar.add(Calendar.DATE, 7);
            this.endDateTime = calendar.getTime();
        }
    }
    
    public Date getStartDate() {
        return startDateTime;
    }
    
    public Date getEndDate() {
        return endDateTime;
    }
}
```
###### \java\seedu\savvytasker\commons\util\SmartDefaultDates.java
``` java

```
###### \java\seedu\savvytasker\logic\commands\AddCommand.java
``` java
    /**
     * Creates an add command.
     */
    public AddCommand(String taskName, InferredDate startDateTime, InferredDate endDateTime,
            String location, PriorityLevel priority, RecurrenceType recurringType, 
            Integer numberOfRecurrence, String category, String description) {
        this.taskName = taskName;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.location = location;
        this.priority = priority;
        this.recurringType = recurringType;
        this.numberOfRecurrence = numberOfRecurrence;
        this.category = category;
        this.description = description;
    }
    
    private void createTask() {
        final boolean isArchived = false;   // all tasks are first added as active tasks
        final int taskId = 0;               // taskId to be assigned by ModelManager, leave as 0
        
        SmartDefaultDates sdd = new SmartDefaultDates(startDateTime, endDateTime);
        this.toAdd = new Task(taskId, taskName, sdd.getStartDate(), sdd.getEndDate(),
                location, priority, recurringType, numberOfRecurrence,
                category, description, isArchived);
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        createTask();

        try {
            model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (InvalidDateException ex) {
            return new CommandResult(MESSAGE_INVALID_START_END);
        }

    }
```
###### \java\seedu\savvytasker\logic\commands\AddCommand.java
``` java
    
    /**
     * Checks if a command can perform undo operations
     * @return true if the command supports undo, false otherwise
     */
    @Override
    public boolean canUndo() {
        return true;
    }

    /**
     * Redo the add command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean redo() {
        execute();
        return false;
    }
    
    /**
     * Undo the add command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean undo() {
        
        UnmodifiableObservableList<Task> lastShownList = model.getFilteredTaskListTask();
        
        for (int i = 0; i < lastShownList.size(); i++) {
            if (lastShownList.get(i) == toAdd){
                ReadOnlyTask taskToDelete = lastShownList.get(i);
                try {
                    model.deleteTask(taskToDelete);
                } catch (TaskNotFoundException e) {
                    e.printStackTrace();
                }
            }
        } 
        return false;
    }
    
    /**
     * Check if command is an undo command
     * @return true if the command is an undo operation, false otherwise
     */
    @Override
    public boolean isUndo() {
        return false;
    }
    
    /**
     * Check if command is a redo command
     * @return true if the command is a redo operation, false otherwise
     */
    @Override
    public boolean isRedo(){
        return false;
    }
}
```
###### \java\seedu\savvytasker\logic\commands\DeleteCommand.java
``` java
    public DeleteCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        LinkedList<ReadOnlyTask> tasksToDelete = new LinkedList<ReadOnlyTask>();
        for(int targetIndex : this.targetIndices) {
            if (lastShownList.size() < targetIndex || targetIndex <= 0) {
                indicateAttemptToExecuteIncorrectCommand();
                return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            tasksToDelete.add(lastShownList.get(targetIndex - 1));
        }
        
        original = new SavvyTasker(model.getSavvyTasker());

        StringBuilder resultSb = new StringBuilder();
        try {
            for(ReadOnlyTask taskToDelete : tasksToDelete) {
                model.deleteTask(taskToDelete);
                //tasksToUndo.add((Task)taskToDelete);
                resultSb.append(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
            }
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(resultSb.toString());
    }
```
###### \java\seedu\savvytasker\logic\commands\DeleteCommand.java
``` java
    
    /**
     * Checks if a command can perform undo operations
     * @return true if the command supports undo, false otherwise
     */
    @Override
    public boolean canUndo() {
        return true;
    }

    /**
     * Redo the delete command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean redo() {
        execute();
        
        /*
         * METHOD 2
        UnmodifiableObservableList<Task> lastShownList = model.getFilteredTaskListTask();
        
        for(Task toUndo : tasksToUndo){
            for (int i = 0; i < lastShownList.size(); i++) {
                if (lastShownList.get(i) == toUndo){
                    ReadOnlyTask taskToDelete = lastShownList.get(i);
                    try {
                        model.deleteTask(taskToDelete);
                    } catch (TaskNotFoundException e) {
                        e.printStackTrace();
                    }
                }
            }
        } 
        */
        return true;
    }

    /**
     * Undo the delete command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean undo() {      

        assert model != null;
        model.resetData(original);
        
        /*
         * METHOD 2
        assert model != null;
  
        for(Task deleted : tasksToUndo)
        try {
            model.addTask(deleted);
        } catch (DuplicateTaskException e) {
            e.printStackTrace();
        }
        */
        return true;
    }
    
    /**
     * Check if command is an undo command
     * @return true if the command is an undo operation, false otherwise
     */
    @Override
    public boolean isUndo() {
        return false;
    }
    
    /**
     * Check if command is a redo command
     * @return true if the command is a redo operation, false otherwise
     */
    @Override
    public boolean isRedo(){
        return false;
    }
}
```
###### \java\seedu\savvytasker\logic\commands\FindCommand.java
``` java
    public FindCommand(FindType findType, String[] keywords) {
        this.findType = findType;
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        FindType _findType = findType;
        if (_findType == null) {
            // use default find type, partial.
            _findType = FindType.Partial;
        }
        model.updateFilteredTaskList(_findType, keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
```
###### \java\seedu\savvytasker\logic\commands\FindCommand.java
``` java
    
    /**
     * Checks if a command can perform undo operations
     * @return true if the command supports undo, false otherwise
     */
    @Override
    public boolean canUndo() {
        return false;
    }

    /**
     * Redo the find command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean redo() {
        // nothing required to be done
        return false;
    }

    /**
     * Undo the find command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean undo() {
        // nothing required to be done
        return false;
    }

    /**
     * Check if command is an undo command
     * @return true if the command is an undo operation, false otherwise
     */
    @Override
    public boolean isUndo() {
        return false;
    }
    
    /**
     * Check if command is a redo command
     * @return true if the command is a redo operation, false otherwise
     */
    @Override
    public boolean isRedo(){
        return false;
    } 
}
```
###### \java\seedu\savvytasker\logic\commands\ListCommand.java
``` java
    /**
     * Creates the List command to list the specified tasks
     * @author A0139915W
     * @param commandModel Arguments for the List command, must not be null
     */
    public ListCommand(ListType listType) {
        this.listType = listType;
    }

    @Override
    public CommandResult execute() {
        ListType _listType = listType;
        if (listType == null) {
            // use default, sort by due date
            _listType = ListType.DueDate;
        }
        switch (_listType)
        {
        case DueDate:
            model.updateFilteredListToShowActiveSortedByDueDate();
            break;
        case PriorityLevel:
            model.updateFilteredListToShowActiveSortedByPriorityLevel();
            break;
        case Archived:
            model.updateFilteredListToShowArchived();
            break;
        default:
            assert false; // should not reach here
        }
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
```
###### \java\seedu\savvytasker\logic\commands\ListCommand.java
``` java
    
    /**
     * Checks if a command can perform undo operations
     * @return true if the command supports undo, false otherwise
     */
    @Override
    public boolean canUndo() {
        return false;
    }

    /**
     * Redo the list command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean redo() {
        // nothing required to be done
        return false;
    }

    
    /**
     * Undo the list command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean undo() {
        // nothing required to be done
        return false;
    }
    
    /**
     * Check if command is an undo command
     * @return true if the command is an undo operation, false otherwise
     */
    @Override
    public boolean isUndo() {
        return false;
    }
    
    /**
     * Check if command is a redo command
     * @return true if the command is a redo operation, false otherwise
     */
    @Override
    public boolean isRedo(){
        return false;
    }
}

```
###### \java\seedu\savvytasker\logic\commands\ModifyCommand.java
``` java
    /**
     * Creates an add command.
     */
    public ModifyCommand(int index, String taskName, InferredDate startDateTime, InferredDate endDateTime, String location,
            PriorityLevel priority, RecurrenceType recurringType, Integer numberOfRecurrence, String category, 
            String description) {
        this.index = index;
        this.taskName = taskName;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.location = location;
        this.priority = priority;
        this.recurringType = recurringType;
        this.numberOfRecurrence = numberOfRecurrence;
        this.category = category;
        this.description = description;
        this.originalTask = null;
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < index) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        

        SmartDefaultDates sdd = new SmartDefaultDates(null, null);

        ReadOnlyTask taskToModify = lastShownList.get(index - 1);
        replacement = new Task(taskToModify, taskName, sdd.getStart(startDateTime), 
                                    sdd.getEnd(endDateTime), location, priority, 
                                    recurringType, numberOfRecurrence, 
                                    category, description);

        try {
            originalTask = (Task)taskToModify;
            model.modifyTask(taskToModify, replacement);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        } catch (InvalidDateException ex) {
            return new CommandResult(Messages.MESSAGE_INVALID_START_END);
        }
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, replacement));
    }
```
###### \java\seedu\savvytasker\logic\commands\ModifyCommand.java
``` java
    
    /**
     * Checks if a command can perform undo operations
     * @return true if the command supports undo, false otherwise
     */
    @Override
    public boolean canUndo() {
        return true;
    }

    /**
     * Redo the add command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean redo() {
        execute();
        return true;
    }
    
    /**
     * Undo the add command
     * @return true if the operation completed successfully, false otherwise
     */
    @Override
    public boolean undo() {

        assert model != null;

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        ReadOnlyTask taskToModify = lastShownList.get(index - 1);

        try {
            model.modifyTask(taskToModify, originalTask);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        } catch (InvalidDateException ex) {
            //TODO: Verify branch
            //assert false : "The target task cannot be having an invalid start end ";
            //return new CommandResult(Messages.MESSAGE_INVALID_START_END);
        }
       
        return true;
    }
    
    /**
     * Check if command is an undo command
     * @return true if the command is an undo operation, false otherwise
     */
    @Override
    public boolean isUndo() {
        return false;
    }
    
    /**
     * Check if command is a redo command
     * @return true if the command is a redo operation, false otherwise
     */
    @Override
    public boolean isRedo(){
        return false;
    }
}
```
###### \java\seedu\savvytasker\logic\parser\FindCommandParser.java
``` java
    @Override
    public FindCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {
            FindType findType = parseFindType(matcher.group(REGEX_REF_FIND_TYPE));
            String[] keywords = parseKeywords(matcher.group(REGEX_REF_KEYWORDS_BEFORE_TYPE),
                    matcher.group(REGEX_REF_KEYWORDS_AFTER_TYPE));
            
            return new FindCommand(findType, keywords);
        }
        
        throw new ParseException(commandText, String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }
```
###### \java\seedu\savvytasker\logic\parser\FindCommandParser.java
``` java
    
    private FindType parseFindType(String findTypeText) throws ParseException {
        if (findTypeText == null)
            return null;
        
        String trimmedFindTypeText = findTypeText.trim();
        try {
            return FindType.valueOfIgnoreCase(trimmedFindTypeText);
        } catch (IllegalArgumentException ex) {
            throw new ParseException(trimmedFindTypeText, "FIND_TYPE: Unknown type '" + findTypeText + "'");
        }
    }
    
    private String[] parseKeywords(String keywordsBefore, String keywordsAfter) throws ParseException {
        String trimmedKeywordsBefore = keywordsBefore.trim();
        String trimmedKeywordsAfter = keywordsAfter.trim();
        
        String[] keywordsArr1 = new String[0];
        String[] keywordsArr2 = new String[0];
        if (!trimmedKeywordsBefore.isEmpty()) keywordsArr1 = trimmedKeywordsBefore.split("\\s+");
        if (!trimmedKeywordsAfter.isEmpty()) keywordsArr2 = trimmedKeywordsAfter.split("\\s+");
        
        if (keywordsArr1.length == 0 && keywordsArr2.length == 0)
            throw new ParseException(trimmedKeywordsBefore + " ... " + trimmedKeywordsAfter,
                    "KEYWORD: Need to specify at least one keyword!");
        
        return concatArray(keywordsArr1, keywordsArr2);
    }

    /**
     * Concatenates 2 arrays into 1 array, in the order the arrays are given.
     * 
     * @param array1 the first array
     * @param array2 the second array
     * @return the new array with the values from each of the given array added into it in order
     */
    private String[] concatArray(String[] array1, String[] array2) {
        String[] newArray = Arrays.copyOf(array1, array1.length + array2.length);
        System.arraycopy(array2, 0, newArray, array1.length, array2.length);
        return newArray;
    }
}
```
###### \java\seedu\savvytasker\model\Model.java
``` java
    /** Deletes the given Task. */
    void deleteTask(ReadOnlyTask target) throws TaskNotFoundException;

    /** Modifies the given Task. */
    void modifyTask(ReadOnlyTask target, Task replacement) throws TaskNotFoundException, InvalidDateException;

    /** Adds the given Task. 
     * @throws {@link DuplicateTaskException} if a duplicate is found
     * */
    void addTask(Task task) throws DuplicateTaskException, InvalidDateException;

    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();
    
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<Task>} */
    UnmodifiableObservableList<Task> getFilteredTaskListTask();

    /** Updates the filter of the filtered task list to show all active tasks sorted by due date */
    void updateFilteredListToShowActiveSortedByDueDate();

    /** Updates the filter of the filtered task list to show all active tasks sorted by priority level */
    void updateFilteredListToShowActiveSortedByPriorityLevel();

    /** Updates the filter of the filtered task list to show all active tasks */
    void updateFilteredListToShowActive();

    /** Updates the filter of the filtered task list to show all archived tasks */
    void updateFilteredListToShowArchived();

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskList(FindType findType, String[] keywords);
```
###### \java\seedu\savvytasker\model\Model.java
``` java

    /** Adds the given AliasSymbol */
    void addAliasSymbol(AliasSymbol symbol) throws DuplicateSymbolKeywordException;
    
    /** Removes an the given AliasSymbol. */
    void removeAliasSymbol(AliasSymbol symbol) throws SymbolKeywordNotFoundException;
}
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
    private final SavvyTasker savvyTasker;
    private final FilteredList<Task> filteredTasks;
    private final SortedList<Task> sortedAndFilteredTasks;

    /**
     * Initializes a ModelManager with the given SavvyTasker
     * and its variables should not be null
     */
    public ModelManager(SavvyTasker src) {
        super();
        assert src != null;

        logger.fine("Initializing with savvy tasker: " + src);

        savvyTasker = new SavvyTasker(src);
        filteredTasks = new FilteredList<>(savvyTasker.getTasks());
        sortedAndFilteredTasks = new SortedList<>(filteredTasks, new TaskSortedByDefault());
        updateFilteredListToShowActive(); // shows only active tasks on start
    }

    public ModelManager() {
        this(new SavvyTasker());
    }

    public ModelManager(ReadOnlySavvyTasker initialData) {
        savvyTasker = new SavvyTasker(initialData);
        filteredTasks = new FilteredList<>(savvyTasker.getTasks());
        sortedAndFilteredTasks = new SortedList<>(filteredTasks, new TaskSortedByDefault());
        updateFilteredListToShowActive(); // shows only active tasks on start
    }
    
    @Override
    public void resetData(ReadOnlySavvyTasker newData) {
        savvyTasker.resetData(newData);
        indicateSavvyTaskerChanged();
    }

    @Override
    public ReadOnlySavvyTasker getSavvyTasker() {
        return savvyTasker;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateSavvyTaskerChanged() {
        raise(new SavvyTaskerChangedEvent(savvyTasker));
    }
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java

    private void indicateAliasSymbolAdded(AliasSymbol symbol) {
        raise(new AliasSymbolChangedEvent(symbol, AliasSymbolChangedEvent.Action.Added));
    }
    
    private void indicateAliasSymbolRemoved(AliasSymbol symbol) {
        raise(new AliasSymbolChangedEvent(symbol, AliasSymbolChangedEvent.Action.Removed));
    }


```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        savvyTasker.removeTask(target);
        indicateSavvyTaskerChanged();
    }

    @Override
    public void modifyTask(ReadOnlyTask target, Task replacement) throws TaskNotFoundException, InvalidDateException {
        savvyTasker.replaceTask(target, replacement);
        indicateSavvyTaskerChanged();
    }

    @Override
    public synchronized void addTask(Task t) throws DuplicateTaskException, InvalidDateException {
        t.setId(savvyTasker.getNextTaskId());
        savvyTasker.addTask(t);
        updateFilteredListToShowActive();
        indicateSavvyTaskerChanged();
    }
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java

    @Override
    public synchronized void addAliasSymbol(AliasSymbol symbol) throws DuplicateSymbolKeywordException {
        savvyTasker.addAliasSymbol(symbol);
        indicateSavvyTaskerChanged();
        indicateAliasSymbolAdded(symbol);
    }

    @Override
    public synchronized void removeAliasSymbol(AliasSymbol symbol) throws SymbolKeywordNotFoundException {
        savvyTasker.removeAliasSymbol(symbol);
        indicateSavvyTaskerChanged();
        indicateAliasSymbolRemoved(symbol);
    }

    //=========== Filtered/Sorted Task List Accessors ===============================================================

```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<ReadOnlyTask>(sortedAndFilteredTasks);
    }
    
    @Override
    public UnmodifiableObservableList<Task> getFilteredTaskListTask() {
        return new UnmodifiableObservableList<Task>(sortedAndFilteredTasks);
    }

    @Override
    public void updateFilteredListToShowActiveSortedByDueDate() {
        updateFilteredListToShowActive(new TaskSortedByDueDate());
    }

    @Override
    public void updateFilteredListToShowActiveSortedByPriorityLevel() {
        updateFilteredListToShowActive(new TaskSortedByPriorityLevel());
    }
    
    @Override
    public void updateFilteredListToShowActive() {
        updateFilteredTaskList(new PredicateExpression(new TaskIsActiveQualifier()));
    }
    private void updateFilteredListToShowActive(Comparator<Task> comparator) {
        updateFilteredTaskList(
                new PredicateExpression(new TaskIsActiveQualifier()),
                comparator);
    }
    
    @Override
    public void updateFilteredListToShowArchived() {
        updateFilteredTaskList(new PredicateExpression(new TaskIsArchivedQualifier()));
    }
    
    @Override
    public void updateFilteredTaskList(FindType findType, String[] keywords) {
        assert findType != null;
        Qualifier qualifier = null;
        switch (findType)
        {
        case Partial:
            qualifier = new TaskNamePartialMatchQualifier(keywords);
            break;
        case Full:
            qualifier = new TaskNameFullMatchQualifier(keywords);
            break;
        case Exact:
            qualifier = new TaskNameExactMatchQualifier(keywords);
            break;
        case Category:
            qualifier = new CategoryPartialMatchQualifier(keywords);
            break;
        default:
            assert false; // should never get here.
        }
        updateFilteredTaskList(new PredicateExpression(qualifier));
    }
    
    private void updateFilteredTaskList(Expression expression) {
        updateFilteredTaskList(expression, new TaskSortedByDefault());
    }

    private void updateFilteredTaskList(Expression expression, Comparator<Task> comparator) {
        filteredTasks.setPredicate(expression::satisfies);
        sortedAndFilteredTasks.setComparator(comparator);
    }
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java

    //========== Inner classes/interfaces used for filtering ==================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
        
        /**
         * Helper method to build Set<String> from String[]
         * @param keywords list of keywords
         */
        default Set<String> createSet(String[] keywords) {
            HashSet<String> _keywords = new HashSet<String>();
            for (String keyword : keywords) {
                _keywords.add(keyword);
            }
            return _keywords;
        }
    }

```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
    /**
     * Qualifier matching a partial word from the set of keywords
     * @author A0139915W
     */
    private class CategoryPartialMatchQualifier implements Qualifier {
        private Set<String> keyWordsToMatch;

        CategoryPartialMatchQualifier(String[] keyWordsToMatch) {
            this.keyWordsToMatch = createSet(keyWordsToMatch);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return keyWordsToMatch.stream()
                    .filter(keyword -> StringUtil.containsPartialIgnoreCase(task.getCategory(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "category(PartialMatch)=" + String.join(", ", keyWordsToMatch);
        }
    }

    /**
     * Qualifier matching a partial word from the set of keywords
     * @author A0139915W
     */
    private class TaskNamePartialMatchQualifier implements Qualifier {
        private Set<String> keyWordsToMatch;

        TaskNamePartialMatchQualifier(String[] keyWordsToMatch) {
            this.keyWordsToMatch = createSet(keyWordsToMatch);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return keyWordsToMatch.stream()
                    .filter(keyword -> StringUtil.containsPartialIgnoreCase(task.getTaskName(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "taskName(PartialMatch)=" + String.join(", ", keyWordsToMatch);
        }
    }

    /**
     * Qualifier matching a full word from the set of keywords
     * @author A0139915W
     */
    private class TaskNameFullMatchQualifier implements Qualifier {
        private Set<String> keyWordsToMatch;

        TaskNameFullMatchQualifier(String[] keyWordsToMatch) {
            this.keyWordsToMatch = createSet(keyWordsToMatch);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return keyWordsToMatch.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(task.getTaskName(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "taskName(FullMatch)=" + String.join(", ", keyWordsToMatch);
        }
    }

    /**
     * Qualifier matching a exactly from the set of keywords
     * @author A0139915W
     */
    private class TaskNameExactMatchQualifier implements Qualifier {
        private Set<String> keyWordsToMatch;

        TaskNameExactMatchQualifier(String[] keyWordsToMatch) {
            this.keyWordsToMatch = new HashSet<String>();
            this.keyWordsToMatch.add(buildSingleString(keyWordsToMatch));
        }
        
        /**
         * Builds a single string to be matched exactly against the task name.
         * @param keyWordsToMatch list of keywords to match.
         * @return A single string built from the list of keywords.
         */
        private String buildSingleString(String[] keyWordsToMatch) {
            StringBuilder sb = new StringBuilder();
            List<String> keywords = Arrays.asList(keyWordsToMatch);
            Iterator<String> itr = keywords.iterator();
            while (itr.hasNext()) {
                sb.append(itr.next());
                if (itr.hasNext()) {
                    sb.append(" ");
                }
            }
            return sb.toString();
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return keyWordsToMatch.stream()
                    .filter(keyword -> StringUtil.containsExactIgnoreCase(task.getTaskName(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "taskName(ExactMatch)=" + String.join(", ", keyWordsToMatch);
        }
    }

    /**
     * Qualifier for checking if {@link Task} is active. Tasks that are not archived are active.
     * @author A0139915W
     *
     */
    private class TaskIsActiveQualifier implements Qualifier {

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.isArchived() == false;
        }

        @Override
        public String toString() {
            return "isArchived=false";
        }
    }
    
    /**
     * Qualifier for checking if {@link Task} is archived
     * @author A0139915W
     *
     */
    private class TaskIsArchivedQualifier implements Qualifier {

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.isArchived() == true;
        }

        @Override
        public String toString() {
            return "isArchived=true";
        }
    }
    
    //========== Inner classes/interfaces used for sorting ==================================================
    
    /**
     * Compares {@link Task} by their default field, id
     * @author A0139915W
     *
     */
    private class TaskSortedByDefault implements Comparator<Task> {
        
        @Override
        public int compare(Task task1, Task task2) {
            if (task1 == null && task2 == null) return 0;
            else if (task1 == null) return 1;
            else if (task2 == null) return -1;
            else return task1.getId() - task2.getId();
        }
        
    }
    
    /**
     * Compares {@link Task} by their DueDate
     * @author A0139915W
     *
     */
    private class TaskSortedByDueDate implements Comparator<Task> {

        @Override
        public int compare(Task task1, Task task2) {
            if (task1 == null && task2 == null) return 0;
            else if (task1 == null) return 1;
            else if (task2 == null) return -1;
            else {
                // End dates can be nulls (floating tasks)
                // Check for existence of endDateTime before comparing
                if (task1.getEndDateTime() == null &&
                    task2.getEndDateTime() == null) {
                    return 0;
                } else if (task1.getEndDateTime() == null) {
                    return 1;
                } else if (task2.getEndDateTime() == null) {
                    return -1;
                } else {
                    return task1.getEndDateTime().compareTo(task2.getEndDateTime());
                }
            }
        }
        
    }
    
    /**
     * Compares {@link Task} by their PriorityLevel
     * @author A0139915W
     *
     */
    private class TaskSortedByPriorityLevel implements Comparator<Task> {

        @Override
        public int compare(Task task1, Task task2) {
            if (task1 == null && task2 == null) return 0;
            else if (task1 == null) return 1;
            else if (task2 == null) return -1;
            else {
                // Priority Level can be nulls
                // Check for existence of priorityLevel before comparing
                if (task1.getPriority() == null &&
                    task2.getPriority() == null) {
                    return 0;
                } else if (task1.getPriority() == null) {
                    return 1;
                } else if (task2.getPriority() == null) {
                    return -1;
                } else {
                    return task2.getPriority().compareTo(task1.getPriority());
                }
            }
        }
        
    }
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java

}
```
###### \java\seedu\savvytasker\model\ReadOnlySavvyTasker.java
``` java
    /**
     * Returns a defensively copied task list.
     */
    TaskList getTaskList();
```
###### \java\seedu\savvytasker\model\ReadOnlySavvyTasker.java
``` java

    /**
     * Returns a defensively copied alias symbol list.
     */
    
    AliasSymbolList getAliasSymbolList();
```
###### \java\seedu\savvytasker\model\ReadOnlySavvyTasker.java
``` java
    /**
     * Returns an unmodifiable view of task list
     */
    List<ReadOnlyTask> getReadOnlyListOfTasks();
```
###### \java\seedu\savvytasker\model\ReadOnlySavvyTasker.java
``` java

    /**
     * Returns unmodifiable view of symbols list
     */
    List<AliasSymbol> getReadOnlyListOfAliasSymbols();
}
```
###### \java\seedu\savvytasker\model\SavvyTasker.java
``` java
    private final TaskList tasks;
```
###### \java\seedu\savvytasker\model\SavvyTasker.java
``` java
    private final AliasSymbolList symbols;

    public SavvyTasker() {
        this.tasks = new TaskList();
        this.symbols = new AliasSymbolList();
    }

    public SavvyTasker(ReadOnlySavvyTasker toBeCopied) {
        this(toBeCopied.getTaskList(), toBeCopied.getAliasSymbolList());
    }

    public SavvyTasker(TaskList tasks, AliasSymbolList symbols) {
        this();
        resetData(tasks.getInternalList());
        this.symbols.reset(symbols);
    }

    public static ReadOnlySavvyTasker getEmptySavvyTasker() {
        return new SavvyTasker();
    }

//// task list overwrite operations

    public ObservableList<Task> getTasks() {
        return tasks.getInternalList();
    }

    public void setTasks(List<Task> tasks) {
        this.tasks.getInternalList().setAll(tasks);
    }

    public void resetData(Collection<? extends ReadOnlyTask> newTasks) {
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList()));
    }

    public void resetData(ReadOnlySavvyTasker newData) {
        resetData(newData.getReadOnlyListOfTasks());
    }

//// symbol/task-level operations

```
###### \java\seedu\savvytasker\model\SavvyTasker.java
``` java
    /**
     * Returns the next available id for use to uniquely identify a task.
     * @author A0139915W
     * @return The next available id.
     */
    public int getNextTaskId() {
        return tasks.getNextId();
    }

    /**
     * Adds a task to savvy tasker.
     * @throws TaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task t) throws DuplicateTaskException, InvalidDateException {
        tasks.add(t);
    }
    
    /**
     * Removes a task from savvy tasker.
     * @param key the task to be removed
     * @return true if the task is removed successfully
     * @throws TaskNotFoundException if the task to be removed does not exist
     */
    public boolean removeTask(ReadOnlyTask key) throws TaskNotFoundException {
        return tasks.remove(key);
    }
    
    /**
     * Replaces a task from savvy tasker.
     * @param key the task to be replaced
     * @return true if the task is removed successfully
     * @throws TaskNotFoundException if the task to be removed does not exist
     */
    public boolean replaceTask(ReadOnlyTask key, Task replacement) throws TaskNotFoundException, InvalidDateException {
        return tasks.replace(key, replacement);
    }
```
###### \java\seedu\savvytasker\model\SavvyTasker.java
``` java
    
    /**
     * Adds an alias symbol to savvy tasker.
     * @param symbol the symbol to add
     * @throws DuplicateSymbolKeywordException if another symbol with the same keyword already exists
     */
    public void addAliasSymbol(AliasSymbol symbol) throws DuplicateSymbolKeywordException {
        symbols.addAliasSymbol(symbol);
    }
    
    /**
     * Removes an alias symbol from savvy tasker.
     * @param symbol the symbol to remove
     * @throws SymbolKeywordNotFoundException  if there is no such symbol
     */
    public void removeAliasSymbol(AliasSymbol symbol) throws SymbolKeywordNotFoundException {
        symbols.removeAliasSymbol(symbol);
    }
    

//// util methods

    @Override
    public String toString() {
        return tasks.getInternalList().size() + " tasks, " + symbols.size() + " symbols";
        // TODO: refine later
    }

    @Override
    public List<ReadOnlyTask> getReadOnlyListOfTasks() {
        return Collections.unmodifiableList(tasks.getInternalList());
    }

    @Override
    public TaskList getTaskList() {
        TaskList defensiveCopy = new TaskList();
        defensiveCopy.getInternalList().addAll(tasks.getInternalList());
        return defensiveCopy;
    }

    @Override
    public List<AliasSymbol> getReadOnlyListOfAliasSymbols() {
        return symbols.asReadonly();
    }

    @Override
    public AliasSymbolList getAliasSymbolList() {
        return new AliasSymbolList(symbols);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof SavvyTasker // instanceof handles nulls
                && this.tasks.equals(((SavvyTasker) other).tasks)
                && this.symbols.equals(((SavvyTasker) other).symbols));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, symbols);
    }
}
```
###### \java\seedu\savvytasker\model\task\ReadOnlyTask.java
``` java
/**
 * A read-only immutable interface for a Task in the TaskList.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {
    
    int getId();
    boolean isMarked();
    boolean isArchived();
    String getTaskName();
    Date getStartDateTime();
    Date getEndDateTime();
    String getLocation();
    PriorityLevel getPriority();
    RecurrenceType getRecurringType();
    int getNumberOfRecurrence();
    String getCategory();
    String getDescription();

    /**
     * Returns true if both tasks have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return getId() == other.getId();
    }

    /**
     * Formats the task as text, showing all task details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(" Id: ")
                .append(getId())
                .append(" Task Name: ")
                .append(getTaskName())
                .append(" Archived: ")
                .append(isArchived())
                .append(" Start: ")
                .append(getStartDateTime())
                .append(" End: ")
                .append(getEndDateTime())
                .append(" Location: ")
                .append(getLocation())
                .append(" Priority: ")
                .append(getPriority())
                .append(" Recurring Type: ")
                .append(getRecurringType())
                .append(" Nr. Recurrence: ")
                .append(getNumberOfRecurrence())
                .append(" Category: ")
                .append(getCategory())
                .append(" Description: ")
                .append(getDescription());
        return builder.toString();
    }

}
```
###### \java\seedu\savvytasker\model\task\ReadOnlyTask.java
``` java

```
###### \java\seedu\savvytasker\model\task\Task.java
``` java
/**
 * Represents a Task in the task list.
 */
public class Task implements ReadOnlyTask {

    private int id;
    private String taskName;
    private Date startDateTime;
    private Date endDateTime;
    private String location;
    private PriorityLevel priority;
    private RecurrenceType recurringType;
    private int numberOfRecurrence;
    private String category;
    private String description;
    private boolean isArchived;

    public Task(int id, String taskName, Date startDateTime, Date endDateTime, String location,
            PriorityLevel priority, RecurrenceType recurringType, Integer numberOfRecurrence, 
            String category, String description, boolean isArchived) {
        this.id = id;
        this.taskName = taskName;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.location = location;
        if (priority == null) {
            this.priority = PriorityLevel.Medium;
        } else {
            this.priority = priority;
        }
        if (recurringType == null) {
            this.recurringType = RecurrenceType.None;
        } else {
            this.recurringType = recurringType;
        }
        if (numberOfRecurrence == null) {
            this.numberOfRecurrence = 0;
        } else {
            this.numberOfRecurrence = numberOfRecurrence.intValue();
        }
        this.category = category;
        this.description = description;
        this.isArchived = isArchived;
    }
    
    public Task(String taskName) {
        this.taskName = taskName;
        // sets initial default values
        this.priority = PriorityLevel.Medium;
        this.recurringType = RecurrenceType.None;
        this.numberOfRecurrence = 0;
    }

    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getId(), source.getTaskName(), source.getStartDateTime(), 
                source.getEndDateTime(), source.getLocation(), source.getPriority(), 
                source.getRecurringType(), source.getNumberOfRecurrence(), 
                source.getCategory(), source.getDescription(), source.isArchived());
    }

    /**
     * Copy and modify constructor
     */
    public Task(ReadOnlyTask source, String taskName, Date startDateTime, Date endDateTime, String location,
            PriorityLevel priority, RecurrenceType recurringType, Integer numberOfRecurrence, String category, 
            String description) {
        this(source.getId(), source.getTaskName(), source.getStartDateTime(), 
                source.getEndDateTime(), source.getLocation(), source.getPriority(), 
                source.getRecurringType(), source.getNumberOfRecurrence(), 
                source.getCategory(), source.getDescription(), source.isArchived());
        
        //this.id should follow that of the source.
        //this.isArchived should follow that of the source.
        this.taskName = taskName == null ? this.taskName : taskName;
        this.startDateTime = startDateTime == null ? this.startDateTime : startDateTime;
        this.endDateTime = endDateTime == null ? this.endDateTime : endDateTime;
        this.location = location == null ? this.location : location;
        this.priority = priority == null ? this.priority : priority;
        this.recurringType = recurringType == null ? this.recurringType : recurringType;
        this.numberOfRecurrence = numberOfRecurrence == null ? this.numberOfRecurrence : numberOfRecurrence.intValue();
        this.category = category == null ? this.category : category;
        this.description = description == null ? this.description : description;
    }

    @Override
    public int getId() {
        return this.id;
    }
    
    @Override
    public boolean isMarked() {
        return isArchived(); // all marked tasks are archived
    }
    
    @Override
    public boolean isArchived() {
        return this.isArchived;
    }

    @Override
    public String getTaskName() {
        return taskName;
    }

    @Override
    public Date getStartDateTime() {
        return startDateTime;
    }

    @Override
    public Date getEndDateTime() {
        return endDateTime;
    }

    @Override
    public String getLocation() {
        return location;
    }

    @Override
    public PriorityLevel getPriority() {
        return priority;
    }

    @Override
    public RecurrenceType getRecurringType() {
        return recurringType;
    }

    @Override
    public int getNumberOfRecurrence() {
        return numberOfRecurrence;
    }

    @Override
    public String getCategory() {
        return category;
    }

    @Override
    public String getDescription() {
        return description;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public void setTaskName(String taskName) {
        this.taskName = taskName;
    }

    public void setStartDateTime(Date startDateTime) {
        this.startDateTime = startDateTime;
    }

    public void setEndDateTime(Date endDateTime) {
        this.endDateTime = endDateTime;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public void setPriority(PriorityLevel priority) {
        this.priority = priority;
    }

    public void setRecurringType(RecurrenceType recurringType) {
        this.recurringType = recurringType;
    }

    public void setNumberOfRecurrence(int numberOfRecurrence) {
        this.numberOfRecurrence = numberOfRecurrence;
    }

    public void setCategory(String category) {
        this.category = category;
    }

    public void setDescription(String description) {
        this.description = description;
    }
    
    public void setArchived(boolean isArchived) {
        if (isArchived) mark();
        else unmark();
    }
    
    /**
     * Marks the task as complete, also moves this task from the active list 
     * to the archived list.
     */
    public void mark() { 
        if (!isMarked()) {
            this.isArchived = true;
        }
    }
    
    /**
     * Unmarks the task as complete, also moves this task from the archived list 
     * to the active list.
     */
    public void unmark() {
        if (isMarked()) {
            this.isArchived = false;
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(taskName);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### \java\seedu\savvytasker\model\task\Task.java
``` java

```
###### \java\seedu\savvytasker\model\task\TaskList.java
``` java
/**
 * A list of tasks that enforces uniqueness between its elements and does not allow nulls.
 *
 * Supports a minimal set of list operations.
 *
 * @see Task#equals(Object)
 */
public class TaskList implements Iterable<Task> {

    /**
     * Signals that an operation would have violated the 'end time earlier than start time' property of the list.
     */
    public static class InvalidDateException extends IllegalValueException {
        
        /**
         * Generated serial ID
         */
        private static final long serialVersionUID = 8933810750762846403L;

        protected InvalidDateException() {
            super("Operation would result in invalid start/end dates");
        }
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        
        /**
         * Generated serial ID
         */
        private static final long serialVersionUID = 8933810750762846403L;

        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would fail because
     * there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {

        /**
         * Generated serial ID
         */
        private static final long serialVersionUID = -7591982407764643511L;
    }

    private final ObservableList<Task> internalList = FXCollections.observableArrayList();
    private int nextId = 0;
    private boolean isNextIdInitialized = false;
    
    /**
     * Constructs empty TaskList.
     */
    public TaskList() {}
    
    /**
     * Gets the next available id for uniquely identifying a task in
     * Savvy Tasker.
     * @return The next available id;
     */
    public int getNextId() {
        if (!isNextIdInitialized) {
            int nextLowest = -1; // first id to be used is 0. Start finding with -1
            LinkedList<Integer> usedIds = new LinkedList<Integer>();
            for (Task t : internalList) {
                usedIds.add(t.getId());
                if (t.getId() > nextLowest) {
                    nextLowest = t.getId();
                }
            }
            // assumption that the number of tasks < 2^31
            // implementation will be buggy if nextId exceeds 2^31
            nextId = nextLowest;
            assert nextId < Integer.MAX_VALUE;
            isNextIdInitialized = true;
        }
        nextId++;
        return nextId;
    }

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Returns true if the end time is not earlier than the start time.
     */
    public boolean isValidStartEnd(ReadOnlyTask toCheck) {
        assert toCheck != null;
        if (toCheck.getStartDateTime() != null && toCheck.getEndDateTime() != null &&
                toCheck.getStartDateTime().compareTo(toCheck.getEndDateTime()) >= 0) {
            return false;
        }
        return true;
    }

    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the person to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) throws DuplicateTaskException, InvalidDateException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        if (!isValidStartEnd(toAdd)) {
            throw new InvalidDateException();
        }
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    /**
     * Replaces the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean replace(ReadOnlyTask toReplace, Task replacement) throws TaskNotFoundException, InvalidDateException {
        assert toReplace != null;
        assert replacement != null;
        if (internalList.contains(toReplace)) {
            if (!isValidStartEnd(replacement)) {
                throw new InvalidDateException();
            }
            internalList.set(internalList.indexOf(toReplace), replacement);
            return true;
        }
        else {
            throw new TaskNotFoundException();
        }
    }

    public ObservableList<Task> getInternalList() {
        return internalList;
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskList // instanceof handles nulls
                && this.internalList.equals( ((TaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### \java\seedu\savvytasker\model\task\TaskList.java
``` java

```
###### \java\seedu\savvytasker\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private int id;
    @XmlElement(required = true)
    private String taskName;
    @XmlElement(required = false)
    private Date startDateTime;
    @XmlElement(required = false)
    private Date endDateTime;
    @XmlElement(required = false)
    private String location;
    @XmlElement(required = false)
    private PriorityLevel priority;
    @XmlElement(required = false)
    private RecurrenceType recurringType;
    @XmlElement(required = false)
    private int numberOfRecurrence;
    @XmlElement(required = false)
    private String category;
    @XmlElement(required = false)
    private String description;
    @XmlElement(required = true)
    private boolean isArchived;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        id = source.getId();
        taskName = source.getTaskName();
        startDateTime = source.getStartDateTime();
        endDateTime = source.getEndDateTime();
        location = source.getLocation();
        priority = source.getPriority();
        recurringType = source.getRecurringType();
        numberOfRecurrence = source.getNumberOfRecurrence();
        category = source.getCategory();
        description = source.getDescription();
        isArchived = source.isArchived();
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted Task
     */
    public Task toModelType() throws IllegalValueException {
        final int id = this.id;
        final String taskName = this.taskName;
        final Date startDateTime = this.startDateTime;
        final Date endDateTime = this.endDateTime;
        final String location = this.location;
        final PriorityLevel priority = this.priority;
        final RecurrenceType recurringType = this.recurringType;
        final int numberOfRecurrence = this.numberOfRecurrence;
        final String category = this.category;
        final String description = this.description;
        final boolean isArchived = this.isArchived;
        return new Task(id, taskName, startDateTime, endDateTime, location, priority,
                recurringType, numberOfRecurrence, category, description, isArchived);
    }
}
```
###### \java\seedu\savvytasker\storage\XmlAdaptedTask.java
``` java

```
