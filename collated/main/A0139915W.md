# A0139915W
###### \java\seedu\savvytasker\commons\events\ui\TaskPanelSelectionChangedEvent.java
``` java

/**
 * Represents a selection change in the Task List Panel
 */
public class TaskPanelSelectionChangedEvent extends BaseEvent {


    private final ReadOnlyTask newSelection;

    public TaskPanelSelectionChangedEvent(ReadOnlyTask newSelection){
        this.newSelection = newSelection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ReadOnlyTask getNewSelection() {
        return newSelection;
    }
}
```
###### \java\seedu\savvytasker\commons\util\SmartDefaultDates.java
``` java
/**
 * Helper functions for handling dates.
 * @author A0139915W
 */

public class SmartDefaultDates {
    
    private Date startDateTime;
    private Date endDateTime;
    private final Calendar calendar;
    private final Calendar today;
    
    /**
     * Determines the smart defaults for the dates provided. Can set both
     * start and end dates as null to get a basic smart default.
     * @param startDateTime Starting date time
     * @param endDateTime Ending date time
     */
    public SmartDefaultDates(InferredDate startDateTime, InferredDate endDateTime) {
        calendar = Calendar.getInstance();
        today = Calendar.getInstance();
        today.setTime(new Date());
        if (startDateTime == null && endDateTime == null) {
            // dates not being supplied, nothing to parse
        } else if (startDateTime == null && endDateTime != null) {
            // apply smart default for endDateTime only
            parseEnd(endDateTime);
        } else if (startDateTime != null && endDateTime == null) {
            // apply smart default for startDateTime only
            parseStart(startDateTime);
        } else {
            parseStartAndEnd(startDateTime, endDateTime);
        }
    }
    
    /**
     * Gets the smart default for end date
     * @param today the time now
     * @param endDateTime the end time to parse
     * @return
     */
    public Date getEnd(InferredDate endDateTime) {
        if (endDateTime == null) return null;
        calendar.setTime(endDateTime.getInferredDateTime());
        if (endDateTime.isDateInferred() && endDateTime.isTimeInferred()) {
            // user didn't specify anything
            // remove date field
            return null;
        } else if (endDateTime.isDateInferred()) {
            // date not supplied
            // defaults to today
            calendar.set(Calendar.DATE, today.get(Calendar.DATE));
            calendar.set(Calendar.MONTH, today.get(Calendar.MONTH));
            calendar.set(Calendar.YEAR, today.get(Calendar.YEAR));
        } else if (endDateTime.isTimeInferred()) {
            // time not supplied
            // defaults to 2359
            calendar.set(Calendar.HOUR_OF_DAY, 23);
            calendar.set(Calendar.MINUTE, 59);
            calendar.set(Calendar.SECOND, 59);
            calendar.set(Calendar.MILLISECOND, 0);
        }
        return calendar.getTime();
    }
    
    /**
     * Sets the starting and ending date/time based on defaults for providing only
     * the end time
     * @param endDateTime end time supplied
     */
    private void parseEnd(InferredDate endDateTime) {
        assert endDateTime.getInferredDateTime() != null;
        Date start = new Date();
        this.endDateTime = getEnd(endDateTime);
        
        // Since only end date is supplied, the task is considered to start at 12am today
        calendar.setTime(start);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        this.startDateTime = calendar.getTime();
        
        if (this.startDateTime.compareTo(this.endDateTime) > 0) {
            // end date is before today, leave start date as null
            this.startDateTime = null;
        }
    }

    
    /**
     * Gets the smart default for start date
     * @param today the time now
     * @param startDateTime the start time to parse
     * @return
     */
    public Date getStart(InferredDate startDateTime) {
        if (startDateTime == null) return null;
        calendar.setTime(startDateTime.getInferredDateTime());
        if (startDateTime.isDateInferred() && startDateTime.isTimeInferred()) {
            // user didn't specify anything
            // remove date field
            return null;
        } else if (startDateTime.isDateInferred()) {
            // date not supplied
            // defaults to today
            calendar.set(Calendar.DATE, today.get(Calendar.DATE));
            calendar.set(Calendar.MONTH, today.get(Calendar.MONTH));
            calendar.set(Calendar.YEAR, today.get(Calendar.YEAR));
        } else if (startDateTime.isTimeInferred()) {
            // time not supplied
            // defaults to 0000
            calendar.set(Calendar.HOUR_OF_DAY, 0);
            calendar.set(Calendar.MINUTE, 0);
            calendar.set(Calendar.SECOND, 0);
            calendar.set(Calendar.MILLISECOND, 0);
        }
        return calendar.getTime();
    }

    
    /**
     * Sets the starting and ending date/time based on defaults for providing only
     * the start time
     * @param startDateTime start time supplied
     */
    private void parseStart(InferredDate startDateTime) {
        assert startDateTime.getInferredDateTime() != null;
        Date end = (Date)startDateTime.getInferredDateTime().clone();
        this.startDateTime = getStart(startDateTime);
        
        // Since only the start time is supplied, the task is considered to end today 2359 on the same day as start.
        calendar.setTime(end);
        calendar.set(Calendar.HOUR_OF_DAY, 23);
        calendar.set(Calendar.MINUTE, 59);
        calendar.set(Calendar.SECOND, 59);
        calendar.set(Calendar.MILLISECOND, 0);
        this.endDateTime = calendar.getTime();
    }

    /**
     * Sets the starting and ending date/time based on defaults for providing both
     * start and end times
     * @param startDateTime start time supplied
     */
    private void parseStartAndEnd(InferredDate startDateTime, InferredDate endDateTime) {
        assert endDateTime.getInferredDateTime() != null;
        assert startDateTime.getInferredDateTime() != null;
        Date start = getStart(startDateTime);
        Date end = getEnd(endDateTime);
        this.startDateTime = start;
        this.endDateTime = end;
    }
    
    public Date getStartDate() {
        return startDateTime;
    }
    
    public Date getEndDate() {
        return endDateTime;
    }
}
```
###### \java\seedu\savvytasker\commons\util\StringUtil.java
``` java
    // reused original implementation of 'containsIgnoreCase' to find exact matches
    public static boolean containsExactIgnoreCase(String source, String query) {
        List<String> strings = Arrays.asList(source);
        return strings.stream().filter(s -> s.equalsIgnoreCase(query)).count() > 0;
    }

    // reused original implementation of 'containsIgnoreCase' to find partial matches
    public static boolean containsPartialIgnoreCase(String source, String query) {
        if (source == null) return false;
        String[] split = source.toLowerCase().split("\\s+");
        List<String> strings = Arrays.asList(split);
        return strings.stream().filter(s -> s.contains(query.toLowerCase())).count() > 0;
    }
```
###### \java\seedu\savvytasker\logic\commands\AddCommand.java
``` java
    /**
     * Creates an add command.
     */
    public AddCommand(String taskName, InferredDate startDateTime, InferredDate endDateTime,
            String location, PriorityLevel priority, RecurrenceType recurringType, 
            Integer numberOfRecurrence, String category, String description) {
        this.taskName = taskName;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.location = location;
        this.priority = priority;
        this.recurringType = recurringType;
        this.numberOfRecurrence = numberOfRecurrence;
        this.category = category;
        this.description = description;
        tasksAdded = new LinkedList<Task>();
    }
    
    private void createTask() {
        final boolean isArchived = false;   // all tasks are first added as active tasks
        final int taskId = 0;               // taskId to be assigned by ModelManager, leave as 0
        final int groupId = 0;              // groupId to be assigned by ModelManager, leave as 0
        
        this.toAdd = new Task(taskId, groupId, taskName, startDateTime, endDateTime,
                location, priority, recurringType, numberOfRecurrence,
                category, description, isArchived);
    }
    
    private void addToListOfTasksAdded(Task... tasks) {
        for (Task t : tasks) {
            tasksAdded.add(t);
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        createTask();

        try {
            Task taskAdded = null;
            if (toAdd.getRecurringType() == RecurrenceType.None) {
                // not a recurring task, add a single task
                taskAdded = model.addTask(toAdd);
                addToListOfTasksAdded(taskAdded);
            } else {
                // a recurring task, add a group of recurring tasks
                LinkedList<Task> tasksAdded = model.addRecurringTask(toAdd);
                taskAdded = tasksAdded.peekFirst();
                addToListOfTasksAdded(tasksAdded.toArray(new Task[tasksAdded.size()]));
            }
            
            int targetIndex = getIndexOfTask(taskAdded);
            if (targetIndex >= 0) {
                EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex));
            } else {
                // GUI should never ever get here
            }
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (InvalidDateException ex) {
            return new CommandResult(MESSAGE_INVALID_START_END);
        }

    }
    
    /**
     * Helper method to retrieve the index of the task in the tasklist that was added.
     * @param task The task to find
     * @return Returns the index of the task in the list, -1 if not found.
     */
    private int getIndexOfTask(Task task) {
        model.updateFilteredListToShowActive(); //because newly added tasks are all active.
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        return lastShownList.indexOf(task);
    }
```
###### \java\seedu\savvytasker\logic\commands\DeleteCommand.java
``` java
    public DeleteCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        LinkedList<ReadOnlyTask> tasksToDelete = new LinkedList<ReadOnlyTask>();
        for(int targetIndex : this.targetIndices) {
            if (lastShownList.size() < targetIndex || targetIndex <= 0) {
                indicateAttemptToExecuteIncorrectCommand();
                return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            tasksToDelete.add(lastShownList.get(targetIndex - 1));
        }
        
        original = new SavvyTasker(model.getSavvyTasker());

        StringBuilder resultSb = new StringBuilder();
        try {
            for(ReadOnlyTask taskToDelete : tasksToDelete) {
                model.deleteTask(taskToDelete);
                //tasksToUndo.add((Task)taskToDelete);
                resultSb.append(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
            }
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(resultSb.toString());
    }
```
###### \java\seedu\savvytasker\logic\commands\FindCommand.java
``` java
    public FindCommand(FindType findType, String[] keywords) {
        this.findType = findType;
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        FindType _findType = findType;
        if (_findType == null) {
            // use default find type, partial.
            _findType = FindType.Partial;
        }
        model.updateFilteredTaskList(_findType, keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
```
###### \java\seedu\savvytasker\logic\commands\ListCommand.java
``` java
    /**
     * Creates the List command to list the specified tasks
     * @author A0139915W
     * @param commandModel Arguments for the List command, must not be null
     */
    public ListCommand(ListType listType) {
        this.listType = listType;
    }

    @Override
    public CommandResult execute() {
        ListType _listType = listType;
        if (listType == null) {
            // use default, sort by due date
            _listType = ListType.DueDate;
        }
        switch (_listType)
        {
        case DueDate:
            model.updateFilteredListToShowActiveSortedByDueDate();
            break;
        case PriorityLevel:
            model.updateFilteredListToShowActiveSortedByPriorityLevel();
            break;
        case Archived:
            model.updateFilteredListToShowArchived();
            break;
        }
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
```
###### \java\seedu\savvytasker\logic\commands\ModifyCommand.java
``` java
    /**
     * Creates an add command.
     */
    public ModifyCommand(int index, String taskName, InferredDate startDateTime, InferredDate endDateTime, String location,
            PriorityLevel priority, RecurrenceType recurringType, Integer numberOfRecurrence, String category, 
            String description) {
        this.index = index;
        this.taskName = taskName;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.location = location;
        this.priority = priority;
        this.recurringType = recurringType;
        this.numberOfRecurrence = numberOfRecurrence;
        this.category = category;
        this.description = description;
        this.originalTask = null;
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < index) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToModify = lastShownList.get(index - 1);
        replacement = new Task(taskToModify, taskName, startDateTime, 
                                    endDateTime, location, priority, 
                                    recurringType, numberOfRecurrence, 
                                    category, description);

        try {
            originalTask = (Task)taskToModify;
            Task taskModified = model.modifyTask(taskToModify, replacement);
            int targetIndex = getIndexOfTask(taskModified);
            if (targetIndex >= 0) {
                EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex));
            } else {
                // GUI should never ever get here
            }
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        } catch (InvalidDateException ex) {
            return new CommandResult(Messages.MESSAGE_INVALID_START_END);
        }
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, replacement));
    }
    
    /**
     * Helper method to retrieve the index of the task in the tasklist that was added.
     * @param task The task to find
     * @return Returns the index of the task in the list, -1 if not found.
     */
    private int getIndexOfTask(Task task) {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        return lastShownList.indexOf(task);
    }
```
###### \java\seedu\savvytasker\logic\parser\FindCommandParser.java
``` java
    @Override
    public FindCommand parse(String commandText) throws ParseException {
        Matcher matcher = REGEX_PATTERN.matcher(commandText);
        if (matcher.matches()) {
            FindType findType = parseFindType(matcher.group(REGEX_REF_FIND_TYPE));
            String[] keywords = parseKeywords(matcher.group(REGEX_REF_KEYWORDS_BEFORE_TYPE),
                    matcher.group(REGEX_REF_KEYWORDS_AFTER_TYPE));
            
            return new FindCommand(findType, keywords);
        }
        
        throw new ParseException(commandText, String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, getRequiredFormat()));
    }
```
###### \java\seedu\savvytasker\model\Model.java
``` java
    /** 
     * Deletes the given Task. 
     * @throws {@link TaskNotFoundException} if the task does not exist
     * @return Returns a Task if the delete operation is successful, an exception is thrown otherwise.
     * */
    Task deleteTask(ReadOnlyTask target) throws TaskNotFoundException;

    /** 
     * Modifies the given Task. 
     * @throws {@link TaskNotFoundException} if the task does not exist
     * @throws {@link InvalidDateException} if the end date is earlier than the start date
     * @return Returns a Task if the modify operation is successful, an exception is thrown otherwise.
     * */
    Task modifyTask(ReadOnlyTask target, Task replacement) throws TaskNotFoundException, InvalidDateException;

    /** Adds the given Task. 
     * @throws {@link DuplicateTaskException} if a duplicate is found
     * @throws {@link InvalidDateException} if the end date is earlier than the start date
     * @return Returns a Task if the add operation is successful, an exception is thrown otherwise.
     * */
    Task addTask(Task task) throws InvalidDateException;
    
    /** Adds the given Task as a recurring task. The task's recurrence type must not be null.
     * @throws {@link DuplicateTaskException} if a duplicate is found
     * @throws {@link InvalidDateException} if the end date is earlier than the start date
     * @return Returns the list of Tasks added if the add operation is successful, an exception is thrown otherwise.
     * */
    LinkedList<Task> addRecurringTask(Task task) throws InvalidDateException;

    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Updates the filter of the filtered task list to show all active tasks sorted by due date */
    void updateFilteredListToShowActiveSortedByDueDate();

    /** Updates the filter of the filtered task list to show all active tasks sorted by priority level */
    void updateFilteredListToShowActiveSortedByPriorityLevel();

    /** Updates the filter of the filtered task list to show all active tasks */
    void updateFilteredListToShowActive();

    /** Updates the filter of the filtered task list to show all archived tasks */
    void updateFilteredListToShowArchived();

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskList(FindType findType, String[] keywords);
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
    private final SavvyTasker savvyTasker;
    private final FilteredList<Task> filteredTasks;
    private final SortedList<Task> sortedAndFilteredTasks;

    /**
     * Initializes a ModelManager with the given SavvyTasker
     * and its variables should not be null
     */
    public ModelManager(SavvyTasker src) {
        super();
        assert src != null;

        logger.fine("Initializing with savvy tasker: " + src);

        savvyTasker = new SavvyTasker(src);
        filteredTasks = new FilteredList<>(savvyTasker.getTasks());
        sortedAndFilteredTasks = new SortedList<>(filteredTasks, new TaskSortedByDueDate());
        updateFilteredListToShowActive(); // shows only active tasks on start
    }

    public ModelManager() {
        this(new SavvyTasker());
    }

    public ModelManager(ReadOnlySavvyTasker initialData) {
        savvyTasker = new SavvyTasker(initialData);
        filteredTasks = new FilteredList<>(savvyTasker.getTasks());
        sortedAndFilteredTasks = new SortedList<>(filteredTasks, new TaskSortedByDueDate());
        updateFilteredListToShowActive(); // shows only active tasks on start
    }
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
    @Override
    public synchronized Task deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        Task taskDeleted = savvyTasker.removeTask(target);
        indicateSavvyTaskerChanged();
        return taskDeleted;
    }

    @Override
    public synchronized Task modifyTask(ReadOnlyTask target, Task replacement) throws TaskNotFoundException, InvalidDateException {
        Task taskModified = savvyTasker.replaceTask(target, replacement);
        indicateSavvyTaskerChanged();
        return taskModified;
    }

    @Override
    public synchronized Task addTask(Task t) throws InvalidDateException {
        Task taskAdded = savvyTasker.addTask(t);
        updateFilteredListToShowActive();
        indicateSavvyTaskerChanged();
        return taskAdded;
    }
    
    @Override
    public synchronized LinkedList<Task> addRecurringTask(Task recurringTask) throws InvalidDateException {
        LinkedList<Task> recurringTasks = savvyTasker.addRecurringTasks(recurringTask);
        updateFilteredListToShowActive();
        indicateSavvyTaskerChanged();
        return recurringTasks;
    }
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<ReadOnlyTask>(sortedAndFilteredTasks);
    }

    @Override
    public void updateFilteredListToShowActiveSortedByDueDate() {
        updateFilteredListToShowActive(new TaskSortedByDueDate());
    }

    @Override
    public void updateFilteredListToShowActiveSortedByPriorityLevel() {
        updateFilteredListToShowActive(new TaskSortedByPriorityLevel());
    }
    
    @Override
    public void updateFilteredListToShowActive() {
        updateFilteredTaskList(new PredicateExpression(new TaskIsActiveQualifier()));
    }
    private void updateFilteredListToShowActive(Comparator<Task> comparator) {
        updateFilteredTaskList(
                new PredicateExpression(new TaskIsActiveQualifier()),
                comparator);
    }
    
    @Override
    public void updateFilteredListToShowArchived() {
        updateFilteredTaskList(new PredicateExpression(new TaskIsArchivedQualifier()));
    }
    
    @Override
    public void updateFilteredTaskList(FindType findType, String[] keywords) {
        assert findType != null;
        Qualifier qualifier = null;
        switch (findType)
        {
        case Partial:
            qualifier = new TaskNamePartialMatchQualifier(keywords);
            break;
        case Full:
            qualifier = new TaskNameFullMatchQualifier(keywords);
            break;
        case Exact:
            qualifier = new TaskNameExactMatchQualifier(keywords);
            break;
        case Category:
            qualifier = new CategoryPartialMatchQualifier(keywords);
            break;
        default:
            assert false; // should never get here.
        }
        updateFilteredTaskList(new PredicateExpression(qualifier));
    }
    
    private void updateFilteredTaskList(Expression expression) {
        updateFilteredTaskList(expression, new TaskSortedByDefault());
    }

    private void updateFilteredTaskList(Expression expression, Comparator<Task> comparator) {
        filteredTasks.setPredicate(expression::satisfies);
        sortedAndFilteredTasks.setComparator(comparator);
    }
```
###### \java\seedu\savvytasker\model\ModelManager.java
``` java
    /**
     * Qualifier matching a partial word from the set of keywords
     * @author A0139915W
     */
    private class CategoryPartialMatchQualifier implements Qualifier {
        private Set<String> keyWordsToMatch;

        CategoryPartialMatchQualifier(String[] keyWordsToMatch) {
            this.keyWordsToMatch = createSet(keyWordsToMatch);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return keyWordsToMatch.stream()
                    .filter(keyword -> StringUtil.containsPartialIgnoreCase(task.getCategory(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "category(PartialMatch)=" + String.join(", ", keyWordsToMatch);
        }
    }

    /**
     * Qualifier matching a partial word from the set of keywords
     * @author A0139915W
     */
    private class TaskNamePartialMatchQualifier implements Qualifier {
        private Set<String> keyWordsToMatch;

        TaskNamePartialMatchQualifier(String[] keyWordsToMatch) {
            this.keyWordsToMatch = createSet(keyWordsToMatch);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return keyWordsToMatch.stream()
                    .filter(keyword -> StringUtil.containsPartialIgnoreCase(task.getTaskName(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "taskName(PartialMatch)=" + String.join(", ", keyWordsToMatch);
        }
    }

    /**
     * Qualifier matching a full word from the set of keywords
     * @author A0139915W
     */
    private class TaskNameFullMatchQualifier implements Qualifier {
        private Set<String> keyWordsToMatch;

        TaskNameFullMatchQualifier(String[] keyWordsToMatch) {
            this.keyWordsToMatch = createSet(keyWordsToMatch);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return keyWordsToMatch.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(task.getTaskName(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "taskName(FullMatch)=" + String.join(", ", keyWordsToMatch);
        }
    }

    /**
     * Qualifier matching a exactly from the set of keywords
     * @author A0139915W
     */
    private class TaskNameExactMatchQualifier implements Qualifier {
        private Set<String> keyWordsToMatch;

        TaskNameExactMatchQualifier(String[] keyWordsToMatch) {
            this.keyWordsToMatch = new HashSet<String>();
            this.keyWordsToMatch.add(buildSingleString(keyWordsToMatch));
        }
        
        /**
         * Builds a single string to be matched exactly against the task name.
         * @param keyWordsToMatch list of keywords to match.
         * @return A single string built from the list of keywords.
         */
        private String buildSingleString(String[] keyWordsToMatch) {
            StringBuilder sb = new StringBuilder();
            List<String> keywords = Arrays.asList(keyWordsToMatch);
            Iterator<String> itr = keywords.iterator();
            while (itr.hasNext()) {
                sb.append(itr.next());
                if (itr.hasNext()) {
                    sb.append(" ");
                }
            }
            return sb.toString();
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return keyWordsToMatch.stream()
                    .filter(keyword -> StringUtil.containsExactIgnoreCase(task.getTaskName(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "taskName(ExactMatch)=" + String.join(", ", keyWordsToMatch);
        }
    }

    /**
     * Qualifier for checking if {@link Task} is active. Tasks that are not archived are active.
     * @author A0139915W
     *
     */
    private class TaskIsActiveQualifier implements Qualifier {

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.isArchived() == false;
        }

        @Override
        public String toString() {
            return "isArchived=false";
        }
    }
    
    /**
     * Qualifier for checking if {@link Task} is archived
     * @author A0139915W
     *
     */
    private class TaskIsArchivedQualifier implements Qualifier {

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.isArchived() == true;
        }

        @Override
        public String toString() {
            return "isArchived=true";
        }
    }
    
    //========== Inner classes/interfaces used for sorting ==================================================
    
    /**
     * Compares {@link Task} by their default field, id
     * @author A0139915W
     *
     */
    private class TaskSortedByDefault implements Comparator<Task> {
        
        @Override
        public int compare(Task task1, Task task2) {
            if (task1 == null && task2 == null) return 0;
            else if (task1 == null) return 1;
            else if (task2 == null) return -1;
            else return task1.getId() - task2.getId();
        }
        
    }
    
    /**
     * Compares {@link Task} by their DueDate
     * @author A0139915W
     *
     */
    private class TaskSortedByDueDate implements Comparator<Task> {

        @Override
        public int compare(Task task1, Task task2) {
            if (task1 == null && task2 == null) return 0;
            else if (task1 == null) return 1;
            else if (task2 == null) return -1;
            else {
                // End dates can be nulls (floating tasks)
                // Check for existence of endDateTime before comparing
                if (task1.getEndDateTime() == null &&
                    task2.getEndDateTime() == null) {
                    return 0;
                } else if (task1.getEndDateTime() == null) {
                    return 1;
                } else if (task2.getEndDateTime() == null) {
                    return -1;
                } else {
                    return task1.getEndDateTime().compareTo(task2.getEndDateTime());
                }
            }
        }
        
    }
    
    /**
     * Compares {@link Task} by their PriorityLevel
     * @author A0139915W
     *
     */
    private class TaskSortedByPriorityLevel implements Comparator<Task> {

        @Override
        public int compare(Task task1, Task task2) {
            if (task1 == null && task2 == null) return 0;
            else if (task1 == null) return 1;
            else if (task2 == null) return -1;
            else {
                return task2.getPriority().compareTo(task1.getPriority());
            }
        }
        
    }
```
###### \java\seedu\savvytasker\model\ReadOnlySavvyTasker.java
``` java
    /**
     * Returns a defensively copied task list.
     */
    TaskList getTaskList();
```
###### \java\seedu\savvytasker\model\ReadOnlySavvyTasker.java
``` java
    /**
     * Returns an unmodifiable view of task list
     */
    List<ReadOnlyTask> getReadOnlyListOfTasks();
```
###### \java\seedu\savvytasker\model\SavvyTasker.java
``` java

    /**
     * Adds a task to savvy tasker.
     * @throws {@link InvalidDateException} if the end date is earlier than the start date
     * @return Returns the task added if the operation succeeds, an exception is thrown otherwise.
     */
    public Task addTask(Task t) throws InvalidDateException {
        // guarantees unique ID
        t.setId(tasks.getNextId());
        try {
            return tasks.add(t);
        } catch (DuplicateTaskException e) {
            // should never get here.
            return null;
        }
    }

    /**
     * Adds a group of recurring tasks to savvy tasker.
     * @throws {@link InvalidDateException} if the end date is earlier than the start date
     * @return Returns the list of recurring tasks if the operation succeeds, an exception is thrown otherwise
     */
    public LinkedList<Task> addRecurringTasks(Task recurringTask) throws InvalidDateException {
        LinkedList<Task> tasksToAdd = 
                createRecurringTasks(recurringTask, recurringTask.getRecurringType(), 
                        recurringTask.getNumberOfRecurrence());
        Iterator<Task> itr = tasksToAdd.iterator();
        
        while(itr.hasNext()) {
            // this will be an atomic operation
            // guaranteed no duplicates
            // if the start/end dates are invalid,
            // the first task to be added will fail immediately, 
            // subsequent tasks will not be added
            try {
                tasks.add(itr.next());
            } catch (DuplicateTaskException e) {
                // should never get here.
                return null;
            } 
        }
        return tasksToAdd;
    }
    
    /**
     * Creates a list of recurring tasks to be added into savvy tasker.
     * @param recurringTask the task that recurs
     * @param recurringType the type of recurrence
     * @param numberOfRecurrences the number of recurrences
     * @return A list of tasks that represents a recurring task.
     */
    private LinkedList<Task> createRecurringTasks(Task recurringTask, RecurrenceType recurringType, int numberOfRecurrences) {
        assert recurringTask.getRecurringType() != null;
        assert recurringTask.getNumberOfRecurrence() > 0;
        
        LinkedList<Task> listOfTasks = new LinkedList<Task>();
        recurringTask.setGroupId(tasks.getNextGroupId());
        
        for (int i = 0; i < numberOfRecurrences; ++i) {
            Task t = recurringTask.clone();
            // guarantees uniqueness
            t.setId(tasks.getNextId());
            listOfTasks.add(setDatesForRecurringType(t, recurringType, i));
        }
        
        return listOfTasks;
    }
    
    /**
     * Helper function for createRecurringTasks(). Sets the respective start/end datetime for the
     * i-th recurring task to be added
     * @param t The first recurring task
     * @param recurringType the type of recurrence
     * @param index the index of the loop
     * @return A task with its respective datetime set.
     */
    private Task setDatesForRecurringType(Task t, RecurrenceType recurringType, int index) {
        Date startDate = t.getStartDateTime();
        Date endDate = t.getEndDateTime();
        Calendar calendar = Calendar.getInstance();
        switch (recurringType) {
        case Daily: // add one day to the i-th task
            if (startDate != null) {
                calendar.setTime(startDate);
                calendar.add(Calendar.DATE, 1 * index);
                startDate = calendar.getTime();
            }
            if (endDate != null) {
                calendar.setTime(endDate);
                calendar.add(Calendar.DATE, 1 * index);
                endDate = calendar.getTime();
            }
            break;
        case Weekly:  // add 7 days to the i-th task
            if (startDate != null) {
                calendar.setTime(startDate);
                calendar.add(Calendar.DATE, 7 * index);
                startDate = calendar.getTime();
            }
            if (endDate != null) {
                calendar.setTime(endDate);
                calendar.add(Calendar.DATE, 7 * index);
                endDate = calendar.getTime();
            }
            break;
        case Monthly: // add 1 month to the i-th task
            if (startDate != null) {
                calendar.setTime(startDate);
                calendar.add(Calendar.MONTH, 1 * index);
                startDate = calendar.getTime();
            }
            if (endDate != null) {
                calendar.setTime(endDate);
                calendar.add(Calendar.MONTH, 1 * index);
                endDate = calendar.getTime();
            }
            break;
        case Yearly: // add 1 year to the i-th task
            if (startDate != null) {
                calendar.setTime(startDate);
                calendar.add(Calendar.YEAR, 1 * index);
                startDate = calendar.getTime();
            }
            if (endDate != null) {
                calendar.setTime(endDate);
                calendar.add(Calendar.YEAR, 1 * index);
                endDate = calendar.getTime();
            }
            break;
        case None:
        default:
            assert false; // should not come here
        }
        t.setStartDateTime(startDate);
        t.setEndDateTime(endDate);
        return t;
    }
    
    /**
     * Removes a task from savvy tasker.
     * @param key the task to be removed
     * @throws {@link TaskNotFoundException} if the task does not exist
     * @return Returns a Task if the remove operation is successful, an exception is thrown otherwise.
     */
    public Task removeTask(ReadOnlyTask key) throws TaskNotFoundException {
        return tasks.remove(key);
    }
    
    /**
     * Replaces a task from savvy tasker.
     * @param key the task to be replaced
     * @throws {@link TaskNotFoundException} if the task does not exist
     * @throws {@link InvalidDateException} if the end date is earlier than the start date
     * @return true if the task is removed successfully
     */
    public Task replaceTask(ReadOnlyTask key, Task replacement) throws TaskNotFoundException, InvalidDateException {
        return tasks.replace(key, replacement);
    }
```
###### \java\seedu\savvytasker\model\SavvyTasker.java
``` java
    @Override
    public List<ReadOnlyTask> getReadOnlyListOfTasks() {
        return Collections.unmodifiableList(tasks.getInternalList());
    }

    @Override
    public TaskList getTaskList() {
        TaskList defensiveCopy = new TaskList();
        defensiveCopy.getInternalList().addAll(tasks.getInternalList());
        return defensiveCopy;
    }
```
###### \java\seedu\savvytasker\model\SavvyTasker.java
``` java
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof SavvyTasker // instanceof handles nulls
                && this.tasks.equals(((SavvyTasker) other).tasks)
                && this.symbols.equals(((SavvyTasker) other).symbols));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, symbols);
    }
```
###### \java\seedu\savvytasker\model\task\ReadOnlyTask.java
``` java
/**
 * A read-only immutable interface for a Task in the TaskList.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {
    
    int getId();
    int getGroupId();
    boolean isMarked();
    boolean isArchived();
    String getTaskName();
    Date getStartDateTime();
    Date getEndDateTime();
    String getLocation();
    PriorityLevel getPriority();
    RecurrenceType getRecurringType();
    int getNumberOfRecurrence();
    String getCategory();
    String getDescription();

    /**
     * Returns true if both tasks have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return getId() == other.getId();
    }

    /**
     * Formats the task as text, showing all task details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(" Id: ")
                .append(getId())
                .append(" Task Name: ")
                .append(getTaskName())
                .append(" Archived: ")
                .append(isArchived());
        if (getStartDateTime() != null) {
            builder.append(" Start: ")
                    .append(getStartDateTime());
        }
        if (getEndDateTime() != null) {
            builder.append(" End: ")
                    .append(getEndDateTime());
        }
        if (getLocation() != null && !getLocation().isEmpty()) {
            builder.append(" Location: ")
                    .append(getLocation());
        }
        builder.append(" Priority: ")
                .append(getPriority());
        if (getCategory() != null && !getCategory().isEmpty()) {
            builder.append(" Category: ")
                    .append(getCategory());
        }
        if (getDescription() != null && !getDescription().isEmpty()) {
            builder.append(" Description: ")
            .       append(getDescription());
        }
        return builder.toString();
    }


    /**
     * Formats the task as text, showing all task details, formatted for the UI.
     */
    default String getTextForUi() {
        final StringBuilder builder = new StringBuilder();
        if (getStartDateTime() != null) {
            builder.append(" Start: ")
                    .append(getStartDateTime())
                    .append("\n");
        }
        if (getEndDateTime() != null) {
            builder.append(" End: ")
                    .append(getEndDateTime())
                    .append("\n");
        }
        if (getLocation() != null && !getLocation().isEmpty()) {
            builder.append(" Location: ")
                    .append(getLocation())
                    .append("\n");
        }
        builder.append(" Priority: ")
                .append(getPriority())
                .append("\n");
        if (getCategory() != null && !getCategory().isEmpty()) {
            builder.append(" Category: ")
                    .append(getCategory())
                    .append("\n");
        }
        if (getDescription() != null && !getDescription().isEmpty()) {
            builder.append(" Description: ")
                    .append(getDescription())
                    .append("\n");
        }
        builder.append(" Archived: ")
                .append(isArchived());
        return builder.toString();
    }

}
```
###### \java\seedu\savvytasker\model\task\Task.java
``` java
/**
 * Represents a Task in the task list.
 */
public class Task implements ReadOnlyTask {

    private int id;
    private int groupId;
    private String taskName;
    private Date startDateTime;
    private Date endDateTime;
    private String location;
    private PriorityLevel priority;
    private RecurrenceType recurringType;
    private int numberOfRecurrence;
    private String category;
    private String description;
    private boolean isArchived;

    /**
     * Constructor with smart defaults
     */
    public Task(int id, int groupId, String taskName, InferredDate startDateTime, InferredDate endDateTime, String location,
            PriorityLevel priority, RecurrenceType recurringType, Integer numberOfRecurrence, 
            String category, String description, boolean isArchived) {
        
        SmartDefaultDates sdd = new SmartDefaultDates(startDateTime, endDateTime);
        this.id = id;
        this.groupId = groupId;
        this.taskName = taskName;
        this.startDateTime = sdd.getStartDate();
        this.endDateTime = sdd.getEndDate();
        this.location = location;
        if (priority == null) {
            this.priority = PriorityLevel.Medium;
        } else {
            this.priority = priority;
        }
        if (recurringType == null) {
            this.recurringType = RecurrenceType.None;
        } else {
            this.recurringType = recurringType;
        }
        if (numberOfRecurrence == null) {
            this.numberOfRecurrence = 1;
        } else {
            this.numberOfRecurrence = numberOfRecurrence.intValue();
        }
        this.category = category;
        this.description = description;
        this.isArchived = isArchived;
    }
    
    /**
     * Constructor without smart defaults
     */
    public Task(int id, int groupId, String taskName, Date startDateTime, Date endDateTime, String location,
            PriorityLevel priority, RecurrenceType recurringType, Integer numberOfRecurrence, 
            String category, String description, boolean isArchived) {
        
        this.id = id;
        this.groupId = groupId;
        this.taskName = taskName;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.location = location;
        if (priority == null) {
            this.priority = PriorityLevel.Medium;
        } else {
            this.priority = priority;
        }
        if (recurringType == null) {
            this.recurringType = RecurrenceType.None;
        } else {
            this.recurringType = recurringType;
        }
        if (numberOfRecurrence == null) {
            this.numberOfRecurrence = 1;
        } else {
            this.numberOfRecurrence = numberOfRecurrence.intValue();
        }
        this.category = category;
        this.description = description;
        this.isArchived = isArchived;
    }
    
    public Task(String taskName) {
        this.taskName = taskName;
        // sets initial default values
        this.priority = PriorityLevel.Medium;
    }

    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getId(), source.getGroupId(), source.getTaskName(), source.getStartDateTime(), 
                source.getEndDateTime(), source.getLocation(), source.getPriority(), 
                source.getRecurringType(), source.getNumberOfRecurrence(), 
                source.getCategory(), source.getDescription(), source.isArchived());
    }

    /**
     * Copy and modify constructor
     */
    public Task(ReadOnlyTask source, String taskName, InferredDate startDateTime, InferredDate endDateTime, String location,
            PriorityLevel priority, RecurrenceType recurringType, Integer numberOfRecurrence, String category, 
            String description) {
        this(source.getId(), source.getGroupId(), source.getTaskName(), source.getStartDateTime(), 
                source.getEndDateTime(), source.getLocation(), source.getPriority(), 
                source.getRecurringType(), source.getNumberOfRecurrence(), 
                source.getCategory(), source.getDescription(), source.isArchived());
        
        //this.id should follow that of the source.
        //this.groupId should follow that of the source.
        //this.isArchived should follow that of the source.
        this.taskName = taskName == null ? this.taskName : taskName;
        setStartDate(startDateTime);
        setEndDate(endDateTime);
        this.location = location == null ? this.location : location;
        this.priority = priority == null ? this.priority : priority;
        this.recurringType = recurringType == null ? this.recurringType : recurringType;
        this.numberOfRecurrence = numberOfRecurrence == null ? this.numberOfRecurrence : numberOfRecurrence.intValue();
        this.category = category == null ? this.category : category;
        this.description = description == null ? this.description : description;
    }
    
    private void setStartDate(InferredDate inferredDate) {
        if (inferredDate == null) {
            // user didn't specify s/
            // keep existing start date
        } else {
            if (inferredDate.isDateInferred() && inferredDate.isTimeInferred()) {
                // user specified s/ but with nothing tagged to it
                // remove existing start date
                this.startDateTime = null;
            } else {
                // user specified s/ with something tagged to it
                // update existing start date
                SmartDefaultDates sdd = new SmartDefaultDates(null, null);
                this.startDateTime = sdd.getStart(inferredDate);
            }
        }
    }
    
    private void setEndDate(InferredDate inferredDate) {
        if (inferredDate == null) {
            // user didn't specify e/
            // keep existing end date
        } else {
            if (inferredDate.isDateInferred() && inferredDate.isTimeInferred()) {
                // user specified e/ but with nothing tagged to it
                // remove existing end date
                this.endDateTime = null;
            } else {
                // user specified e/ with something tagged to it
                // update existing end date
                SmartDefaultDates sdd = new SmartDefaultDates(null, null);
                this.endDateTime = sdd.getStart(inferredDate);
            }
        }
    }

    @Override
    public int getId() {
        return this.id;
    }
    
    @Override
    public int getGroupId() {
        return this.groupId;
    }
    
    @Override
    public boolean isMarked() {
        return isArchived(); // all marked tasks are archived
    }
    
    @Override
    public boolean isArchived() {
        return this.isArchived;
    }

    @Override
    public String getTaskName() {
        return taskName;
    }

    @Override
    public Date getStartDateTime() {
        return startDateTime;
    }

    @Override
    public Date getEndDateTime() {
        return endDateTime;
    }

    @Override
    public String getLocation() {
        return location;
    }

    @Override
    public PriorityLevel getPriority() {
        return priority;
    }

    @Override
    public RecurrenceType getRecurringType() {
        return recurringType;
    }

    @Override
    public int getNumberOfRecurrence() {
        return numberOfRecurrence;
    }

    @Override
    public String getCategory() {
        return category;
    }

    @Override
    public String getDescription() {
        return description;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public void setGroupId(int groupId) {
        this.groupId = groupId;
    }
    
    public void setTaskName(String taskName) {
        this.taskName = taskName;
    }

    public void setStartDateTime(Date startDateTime) {
        this.startDateTime = startDateTime;
    }

    public void setEndDateTime(Date endDateTime) {
        this.endDateTime = endDateTime;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public void setPriority(PriorityLevel priority) {
        this.priority = priority;
    }

    public void setRecurringType(RecurrenceType recurringType) {
        this.recurringType = recurringType;
    }

    public void setNumberOfRecurrence(int numberOfRecurrence) {
        this.numberOfRecurrence = numberOfRecurrence;
    }

    public void setCategory(String category) {
        this.category = category;
    }

    public void setDescription(String description) {
        this.description = description;
    }
    
    public void setArchived(boolean isArchived) {
        if (isArchived) mark();
        else unmark();
    }
    
    /**
     * Marks the task as complete, also moves this task from the active list 
     * to the archived list.
     */
    public void mark() { 
        if (!isMarked()) {
            this.isArchived = true;
        }
    }
    
    /**
     * Unmarks the task as complete, also moves this task from the archived list 
     * to the active list.
     */
    public void unmark() {
        if (isMarked()) {
            this.isArchived = false;
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(taskName);
    }

    @Override
    public String toString() {
        return getAsText();
    }
    
    /**
     * Creates a deep copy of this object.
     */
    public Task clone() {
        Task t = new Task(id, groupId, taskName, 
                (Date)startDateTime.clone(), (Date)endDateTime.clone(),
                location, priority, recurringType, numberOfRecurrence, 
                category, description, isArchived);
        return t;
    }

}
```
###### \java\seedu\savvytasker\model\task\TaskList.java
``` java
/**
 * A list of tasks that enforces uniqueness between its elements and does not allow nulls.
 *
 * Supports a minimal set of list operations.
 *
 * @see Task#equals(Object)
 */
public class TaskList implements Iterable<Task> {

    /**
     * Signals that an operation would have violated the 'end time earlier than start time' property of the list.
     */
    public static class InvalidDateException extends IllegalValueException {
        
        /**
         * Generated serial ID
         */
        private static final long serialVersionUID = 8933810750762846403L;

        protected InvalidDateException() {
            super("Operation would result in invalid start/end dates");
        }
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        
        /**
         * Generated serial ID
         */
        private static final long serialVersionUID = 8933810750762846403L;

        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would fail because
     * there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {

        /**
         * Generated serial ID
         */
        private static final long serialVersionUID = -7591982407764643511L;
    }

    private final ObservableList<Task> internalList = FXCollections.observableArrayList();
    private int nextId = 0;
    private boolean isNextIdInitialized = false;
    private int nextGroupId = 0;
    private boolean isNextGroupIdInitialized = false;
    
    /**
     * Constructs empty TaskList.
     */
    public TaskList() {}
    
    /**
     * Gets the next available id for uniquely identifying a task in
     * Savvy Tasker.
     * @return The next available id;
     */
    public int getNextId() {
        if (!isNextIdInitialized) {
            int nextLowest = 0; // first id to be used is 1. Start finding with 0
            for (Task t : internalList) {
                if (t.getId() > nextLowest) {
                    nextLowest = t.getId();
                }
            }
            // assumption that the number of tasks < 2^31
            // implementation will be buggy if nextId exceeds 2^31
            nextId = nextLowest;
            assert nextId < Integer.MAX_VALUE;
            isNextIdInitialized = true;
        }
        nextId++;
        return nextId;
    }
    
    /**
     * Gets the next available group id for uniquely identifying a group of recurring tasks in
     * Savvy Tasker.
     * @return The next available group id;
     */
    public int getNextGroupId() {
        if (!isNextGroupIdInitialized) {
            int nextLowest = 0; // first id to be used is 1. Start finding with 0
            for (Task t : internalList) {
                if (t.getId() > nextLowest) {
                    nextLowest = t.getGroupId();
                }
            }
            // assumption that the number of tasks < 2^31
            // implementation will be buggy if nextId exceeds 2^31
            nextGroupId = nextLowest;
            assert nextGroupId < Integer.MAX_VALUE;
            isNextGroupIdInitialized = true;
        }
        nextGroupId++;
        return nextGroupId;
    }

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Returns true if the end time is not earlier than the start time.
     */
    public boolean isValidStartEnd(ReadOnlyTask toCheck) {
        assert toCheck != null;
        if (toCheck.getStartDateTime() != null && toCheck.getEndDateTime() != null &&
                toCheck.getStartDateTime().compareTo(toCheck.getEndDateTime()) >= 0) {
            return false;
        }
        return true;
    }

    /**
     * Adds a task to the list.
     * @throws {@link DuplicateTaskException} if a duplicate is found
     * @throws {@link InvalidDateException} if the end date is earlier than the start date
     * @return Returns the Task added if the add is successful, an exception is thrown otherwise.
     */
    public Task add(Task toAdd) throws DuplicateTaskException, InvalidDateException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        if (!isValidStartEnd(toAdd)) {
            throw new InvalidDateException();
        }
        internalList.add(toAdd);
        return toAdd;
    }

    /**
     * Removes the equivalent task from the list.
     * @throws {@link TaskNotFoundException} if the task does not exist
     * @return Returns a Task if the delete operation is successful, an exception is thrown otherwise.
     */
    public Task remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        int index = internalList.indexOf(toRemove);
        if (index >= 0) {
            final Task taskToDelete = internalList.get(index);
            final boolean taskFoundAndDeleted = internalList.remove(toRemove);
            if (!taskFoundAndDeleted) {
                throw new TaskNotFoundException();
            }
            return taskToDelete;
        } else {
            throw new TaskNotFoundException();
        }
    }

    /**
     * Replaces the equivalent task from the list.
     * @throws {@link TaskNotFoundException} if the task does not exist
     * @throws {@link InvalidDateException} if the end date is earlier than the start date
     * @return Returns the Task replaced if the replace is successful, an exception is thrown otherwise.
     */
    public Task replace(ReadOnlyTask toReplace, Task replacement) throws TaskNotFoundException, InvalidDateException {
        assert toReplace != null;
        assert replacement != null;
        if (internalList.contains(toReplace)) {
            if (!isValidStartEnd(replacement)) {
                throw new InvalidDateException();
            }
            internalList.set(internalList.indexOf(toReplace), replacement);
            return replacement;
        }
        else {
            throw new TaskNotFoundException();
        }
    }

    public ObservableList<Task> getInternalList() {
        return internalList;
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskList // instanceof handles nulls
                && this.internalList.equals( ((TaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### \java\seedu\savvytasker\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private int id;
    @XmlElement(required = false)
    private int groupId;
    @XmlElement(required = true)
    private String taskName;
    @XmlElement(required = false)
    private Date startDateTime;
    @XmlElement(required = false)
    private Date endDateTime;
    @XmlElement(required = false)
    private String location;
    @XmlElement(required = false)
    private PriorityLevel priority;
    @XmlElement(required = false)
    private String category;
    @XmlElement(required = false)
    private String description;
    @XmlElement(required = true)
    private boolean isArchived;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        id = source.getId();
        groupId = source.getGroupId();
        taskName = source.getTaskName();
        startDateTime = source.getStartDateTime();
        endDateTime = source.getEndDateTime();
        location = source.getLocation();
        priority = source.getPriority();
        category = source.getCategory();
        description = source.getDescription();
        isArchived = source.isArchived();
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted Task
     */
    public Task toModelType() throws IllegalValueException {
        final int id = this.id;
        final String taskName = this.taskName;
        final Date startDateTime = this.startDateTime;
        final Date endDateTime = this.endDateTime;
        final String location = this.location;
        final PriorityLevel priority = this.priority;
        final String category = this.category;
        final String description = this.description;
        final boolean isArchived = this.isArchived;
        return new Task(id, groupId, taskName, startDateTime, endDateTime, location, priority,
                null, null, category, description, isArchived);
    }
}
```
