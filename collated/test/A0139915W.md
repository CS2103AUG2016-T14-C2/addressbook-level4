# A0139915W
###### \java\guitests\AddCommandTest.java
``` java
public class AddCommandTest extends SavvyTaskerGuiTest {

    @Test
    public void add() {
        //add one task
        TestTask[] currentList = td.getTypicalTasks();
        TestTask taskToAdd = td.happy;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        //add another task
        taskToAdd = td.haloween;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        //add to empty list
        commandBox.runCommand("clear");
        assertAddSuccess(td.highPriority);

        //invalid command
        commandBox.runCommand("adds Bad Command Task");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    private void assertAddSuccess(TestTask taskToAdd, TestTask... currentList) {
        commandBox.runCommand(taskToAdd.getAddCommand());

        //confirm the new card contains the right data
        TaskCardHandle addedCard = taskListPanel.navigateToTask(taskToAdd.getTaskName());
        assertMatching(taskToAdd, addedCard);

        //confirm the list now contains all previous persons plus the new person
        TestTask[] expectedList = TestUtil.addTasksToList(currentList, taskToAdd);
        assertTrue(taskListPanel.isListMatching(expectedList));
    }

}
```
###### \java\guitests\AddCommandTest.java
``` java

```
###### \java\guitests\guihandles\TaskListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the person list.
 */
public class TaskListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPane";

    private static final String TASK_LIST_VIEW_ID = "#taskListView";

    public TaskListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<ReadOnlyTask> getSelectedTasks() {
        ListView<ReadOnlyTask> taskList = getListView();
        return taskList.getSelectionModel().getSelectedItems();
    }

    @SuppressWarnings("unchecked")
    public ListView<ReadOnlyTask> getListView() {
        // Should be a listview of readonlytask only.
        return (ListView<ReadOnlyTask>) getNode(TASK_LIST_VIEW_ID);
    }

    /**
     * Returns true if the list is showing the person details correctly and in correct order.
     * @param persons A list of person in the correct order.
     */
    public boolean isListMatching(ReadOnlyTask... tasks) {
        return this.isListMatching(0, tasks);
    }
    
    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point= TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code persons} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyTask... tasks) {
        List<ReadOnlyTask> tasksInList = getListView().getItems();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + tasks.length > tasksInList.size()){
            return false;
        }

        // Return false if any of the persons doesn't match
        for (int i = 0; i < tasks.length; i++) {
            if (!tasksInList.get(startPosition + i).getTaskName().equals(tasks[i].getTaskName())){
                return false;
            }
        }

        return true;
    }

    /**
     * Returns true if the list is showing the person details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param persons A list of person in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyTask... tasks) throws IllegalArgumentException {
        if (tasks.length + startPosition != getListView().getItems().size()) {
            throw new IllegalArgumentException("List size mismatched\n" +
                    "Expected " + (getListView().getItems().size()) + " tasks");
        }
        assertTrue(this.containsInOrder(startPosition, tasks));
        for (int i = 0; i < tasks.length; i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndTask(getTaskCardHandle(startPosition + i), tasks[i])) {
                return false;
            }
        }
        return true;
    }


    public TaskCardHandle navigateToTask(String name) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated
        final Optional<ReadOnlyTask> task = getListView().getItems().stream().filter(p -> p.getTaskName().equals(name)).findAny();
        if (!task.isPresent()) {
            throw new IllegalStateException("Name not found: " + name);
        }

        return navigateToTask(task.get());
    }

    /**
     * Navigates the listview to display and select the person.
     */
    public TaskCardHandle navigateToTask(ReadOnlyTask task) {
        int index = getTaskIndex(task);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getTaskCardHandle(task);
    }


    /**
     * Returns the position of the person given, {@code NOT_FOUND} if not found in the list.
     */
    public int getTaskIndex(ReadOnlyTask targetTask) {
        List<ReadOnlyTask> tasksInList = getListView().getItems();
        for (int i = 0; i < tasksInList.size(); i++) {
            if(tasksInList.get(i).getTaskName().equals(targetTask.getTaskName())){
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a person from the list by index
     */
    public ReadOnlyTask getTask(int index) {
        return getListView().getItems().get(index);
    }

    public TaskCardHandle getTaskCardHandle(int index) {
        return getTaskCardHandle(new Task(getListView().getItems().get(index)));
    }

    public TaskCardHandle getTaskCardHandle(ReadOnlyTask task) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> taskCardNode = nodes.stream()
                .filter(n -> new TaskCardHandle(guiRobot, primaryStage, n).isSameTask(task))
                .findFirst();
        if (taskCardNode.isPresent()) {
            return new TaskCardHandle(guiRobot, primaryStage, taskCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfTasks() {
        return getListView().getItems().size();
    }
}
```
###### \java\guitests\guihandles\TaskListPanelHandle.java
``` java

```
###### \java\seedu\savvytasker\testutil\SavvyTaskerBuilder.java
``` java
/**
 * A utility class to help with building SavvyTasker objects.
 * Example usage: <br>
 *     {@code SavvyTasker st = new SavvyTaskerBuilder().withTask("Hello Task").build();}
 */
public class SavvyTaskerBuilder {

    private SavvyTasker savvyTasker;

    public SavvyTaskerBuilder(SavvyTasker savvyTasker){
        this.savvyTasker = savvyTasker;
    }

    public SavvyTaskerBuilder withTask(Task task) throws DuplicateTaskException, InvalidDateException {
        savvyTasker.addTask(task);
        return this;
    }

    public SavvyTasker build(){
        return savvyTasker;
    }
}
```
###### \java\seedu\savvytasker\testutil\SavvyTaskerBuilder.java
``` java

```
###### \java\seedu\savvytasker\testutil\TaskBuilder.java
``` java
/**
 * Helper to build Task objects
 */
public class TaskBuilder {

    private TestTask task;

    public TaskBuilder() {
        this.task = new TestTask();
    }
    
    public TaskBuilder withId(int id) {
        this.task.setId(id);
        return this;
    }

    public TaskBuilder withTaskName(String taskName) throws IllegalValueException {
        this.task.setTaskName(taskName);
        return this;
    }
    
    public TaskBuilder withStartDateTime(Date startDateTime) {
        this.task.setStartDateTime(startDateTime);
        return this;
    }
    
    public TaskBuilder withEndDateTime(Date endDateTime) {
        this.task.setEndDateTime(endDateTime);
        return this;
    }
    
    public TaskBuilder withLocation(String location) {
        this.task.setLocation(location);
        return this;
    }
    
    public TaskBuilder withPriority(PriorityLevel priority) {
        this.task.setPriority(priority);
        return this;
    }
    
    public TaskBuilder withRecurringType(RecurrenceType recurringType) {
        this.task.setRecurringType(recurringType);
        return this;
    }
    
    public TaskBuilder withNumberOfRecurrence(int numberOfRecurrence) {
        this.task.setNumberOfRecurrence(numberOfRecurrence);
        return this;
    }
    
    public TaskBuilder withCategory(String category) {
        this.task.setCategory(category);
        return this;
    }
    
    public TaskBuilder withDescription(String description) {
        this.task.setDescription(description);
        return this;
    }
    
    public TaskBuilder withArchived(boolean isArchived) {
        this.task.setArchived(isArchived);
        return this;
    }

    public TestTask build() {
        return this.task;
    }

}
```
###### \java\seedu\savvytasker\testutil\TaskBuilder.java
``` java

```
###### \java\seedu\savvytasker\testutil\TestUtil.java
``` java
    public static final Task[] sampleTaskData = getSampleTaskData();

    private static Task[] getSampleTaskData() {
        return new Task[]{
                new Task("Sample Task Leh"),
                new Task("Sample Task La"),
                new Task("Sample Task Lo"),
                new Task("Sample Task Ah")
        };
    }
```
###### \java\seedu\savvytasker\testutil\TestUtil.java
``` java
    
    public static List<Task> generateSampleTaskData() {
        return Arrays.asList(sampleTaskData);
    }

    /**
     * Appends the file name to the sandbox folder path.
     * Creates the sandbox folder if it doesn't exist.
     * @param fileName
     * @return
     */
    public static String getFilePathInSandboxFolder(String fileName) {
        try {
            FileUtil.createDirs(new File(SANDBOX_FOLDER));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return SANDBOX_FOLDER + fileName;
    }

    public static void createDataFileWithSampleData(String filePath) {
        createDataFileWithData(generateSampleStorageSavvyTasker(), filePath);
    }

    public static <T> void createDataFileWithData(T data, String filePath) {
        try {
            File saveFileForTesting = new File(filePath);
            FileUtil.createIfMissing(saveFileForTesting);
            XmlUtil.saveDataToFile(saveFileForTesting, data);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String... s) {
        createDataFileWithSampleData(TestApp.SAVE_LOCATION_FOR_TESTING);
    }

    public static SavvyTasker generateEmptySavvyTasker() {
        return new SavvyTasker(new TaskList(), new AliasSymbolList());
    }

    public static XmlSerializableSavvyTasker generateSampleStorageSavvyTasker() {
        return new XmlSerializableSavvyTasker(generateEmptySavvyTasker());
    }

    /**
     * Tweaks the {@code keyCodeCombination} to resolve the {@code KeyCode.SHORTCUT} to their
     * respective platform-specific keycodes
     */
    public static KeyCode[] scrub(KeyCodeCombination keyCodeCombination) {
        List<KeyCode> keys = new ArrayList<>();
        if (keyCodeCombination.getAlt() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.ALT);
        }
        if (keyCodeCombination.getShift() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.SHIFT);
        }
        if (keyCodeCombination.getMeta() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.META);
        }
        if (keyCodeCombination.getControl() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.CONTROL);
        }
        keys.add(keyCodeCombination.getCode());
        return keys.toArray(new KeyCode[]{});
    }

    public static boolean isHeadlessEnvironment() {
        String headlessProperty = System.getProperty("testfx.headless");
        return headlessProperty != null && headlessProperty.equals("true");
    }

    public static void captureScreenShot(String fileName) {
        File file = GuiTest.captureScreenshot();
        try {
            Files.copy(file, new File(fileName + ".png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static String descOnFail(Object... comparedObjects) {
        return "Comparison failed \n"
                + Arrays.asList(comparedObjects).stream()
                .map(Object::toString)
                .collect(Collectors.joining("\n"));
    }

    public static void setFinalStatic(Field field, Object newValue) throws NoSuchFieldException, IllegalAccessException{
        field.setAccessible(true);
        // remove final modifier from field
        Field modifiersField = Field.class.getDeclaredField("modifiers");
        modifiersField.setAccessible(true);
        // ~Modifier.FINAL is used to remove the final modifier from field so that its value is no longer
        // final and can be changed
        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
        field.set(null, newValue);
    }

    public static void initRuntime() throws TimeoutException {
        FxToolkit.registerPrimaryStage();
        FxToolkit.hideStage();
    }

    public static void tearDownRuntime() throws Exception {
        FxToolkit.cleanupStages();
    }

    /**
     * Gets private method of a class
     * Invoke the method using method.invoke(objectInstance, params...)
     *
     * Caveat: only find method declared in the current Class, not inherited from supertypes
     */
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public static Method getPrivateMethod(Class objectClass, String methodName) throws NoSuchMethodException {
        Method method = objectClass.getDeclaredMethod(methodName);
        method.setAccessible(true);
        return method;
    }

    public static void renameFile(File file, String newFileName) {
        try {
            Files.copy(file, new File(newFileName));
        } catch (IOException e1) {
            e1.printStackTrace();
        }
    }

    /**
     * Gets mid point of a node relative to the screen.
     * @param node
     * @return
     */
    public static Point2D getScreenMidPoint(Node node) {
        double x = getScreenPos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
        double y = getScreenPos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
        return new Point2D(x,y);
    }

    /**
     * Gets mid point of a node relative to its scene.
     * @param node
     * @return
     */
    public static Point2D getSceneMidPoint(Node node) {
        double x = getScenePos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
        double y = getScenePos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
        return new Point2D(x,y);
    }

    /**
     * Gets the bound of the node relative to the parent scene.
     * @param node
     * @return
     */
    public static Bounds getScenePos(Node node) {
        return node.localToScene(node.getBoundsInLocal());
    }

    public static Bounds getScreenPos(Node node) {
        return node.localToScreen(node.getBoundsInLocal());
    }

    public static double getSceneMaxX(Scene scene) {
        return scene.getX() + scene.getWidth();
    }

    public static double getSceneMaxY(Scene scene) {
        return scene.getX() + scene.getHeight();
    }

    public static Object getLastElement(List<?> list) {
        return list.get(list.size() - 1);
    }

```
###### \java\seedu\savvytasker\testutil\TestUtil.java
``` java
    /**
     * Removes a subset from the list of tasks.
     * @param tasks The list of tasks
     * @param tasksToRemove The subset of tasjs.
     * @return The modified tasks after removal of the subset from tasks.
     */
    public static TestTask[] removeTasksFromList(final TestTask[] tasks, TestTask... tasksToRemove) {
        List<TestTask> listOfTasks = asList(tasks);
        listOfTasks.removeAll(asList(tasksToRemove));
        return listOfTasks.toArray(new TestTask[listOfTasks.size()]);
    }


    /**
     * Returns a copy of the list with the task at specified index removed.
     * @param list original list to copy from
     * @param targetIndexInOneIndexedFormat e.g. if the first element to be removed, 1 should be given as index.
     */
    public static TestTask[] removeTaskFromList(final TestTask[] list, int targetIndexInOneIndexedFormat) {
        return removeTasksFromList(list, list[targetIndexInOneIndexedFormat-1]);
    }

    /**
     * Replaces tasks[i] with a task.
     * @param tasks The array of tasks.
     * @param task The replacement task
     * @param index The index of the task to be replaced.
     * @return
     */
    public static TestTask[] replaceTaskFromList(TestTask[] tasks, TestTask task, int index) {
        tasks[index] = task;
        return tasks;
    }

    /**
     * Appends tasks to the array of tasks.
     * @param tasks A array of tasks.
     * @param tasksToAdd The tasks that are to be appended behind the original array.
     * @return The modified array of tasks.
     */
    public static TestTask[] addTasksToList(final TestTask[] tasks, TestTask... tasksToAdd) {
        List<TestTask> listOfTasks = asList(tasks);
        listOfTasks.addAll(asList(tasksToAdd));
        return listOfTasks.toArray(new TestTask[listOfTasks.size()]);
    }
```
###### \java\seedu\savvytasker\testutil\TestUtil.java
``` java

    private static <T> List<T> asList(T[] objs) {
        List<T> list = new ArrayList<>();
        for(T obj : objs) {
            list.add(obj);
        }
        return list;
    }

```
###### \java\seedu\savvytasker\testutil\TestUtil.java
``` java
    public static boolean compareCardAndTask(TaskCardHandle card, ReadOnlyTask task) {
        return card.isSameTask(task);
    }
```
###### \java\seedu\savvytasker\testutil\TestUtil.java
``` java

}
```
###### \java\seedu\savvytasker\testutil\TypicalTestTasks.java
``` java
/**
 *  Test tasks used to test cases
 */
public class TypicalTestTasks {

    public TestTask highPriority, medPriority, lowPriority, furthestDue, 
                            nearerDue, notSoNearerDue, earliestDue, longDue, happy, haloween;
    private SimpleDateFormat format = new SimpleDateFormat("dd/MM/yyyy");
            
    public TypicalTestTasks() {
        try {
            highPriority =  new TaskBuilder().withId(0).withTaskName("High Priority Task")
                                .withPriority(PriorityLevel.High).build();
            medPriority =  new TaskBuilder().withId(1).withTaskName("Medium Priority Task")
                                .withPriority(PriorityLevel.Medium).build();
            lowPriority =  new TaskBuilder().withId(2).withTaskName("Low Priority Task")
                                .withPriority(PriorityLevel.Low).build();
            furthestDue =  new TaskBuilder().withId(3).withTaskName("Furthest Due Task")
                                .withEndDateTime(getDate("01/12/2016")).build();
            nearerDue =  new TaskBuilder().withId(4).withTaskName("Nearer Due Task")
                                .withEndDateTime(getDate("01/11/2016")).build();
            notSoNearerDue =  new TaskBuilder().withId(5).withTaskName("Not So Nearer Due Task")
                    .withEndDateTime(getDate("02/11/2016")).build();
            earliestDue =  new TaskBuilder().withId(6).withTaskName("Earliest Due Task")
                                .withEndDateTime(getDate("01/10/2016")).build();
            longDue =  new TaskBuilder().withId(7).withTaskName("Long Due Task")
                    .withEndDateTime(getDate("01/1/2016")).withArchived(true).build();
            
            //Manually added
            happy = new TaskBuilder().withId(8).withTaskName("Happy Task").build();
            haloween = new TaskBuilder().withId(9).withTaskName("Haloween Task").build();
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public static void loadSavvyTaskerWithSampleData(SavvyTasker st) {
        TypicalTestTasks td = new TypicalTestTasks();
        try {
            st.addTask(new Task(td.highPriority));
            st.addTask(new Task(td.medPriority));
            st.addTask(new Task(td.lowPriority));
            st.addTask(new Task(td.furthestDue));
            st.addTask(new Task(td.nearerDue));
            st.addTask(new Task(td.notSoNearerDue));
            st.addTask(new Task(td.earliestDue));
            st.addTask(new Task(td.longDue));
        } catch (DuplicateTaskException e) {
            assert false : "not possible";
        } catch (InvalidDateException e) {
            assert false : "not possible";
        }
    }

    public TestTask[] getTypicalTasks() {
        return new TestTask[]{ highPriority, medPriority, lowPriority, 
                furthestDue, nearerDue, notSoNearerDue, earliestDue };
    }

    public SavvyTasker getTypicalSavvyTasker(){
        SavvyTasker st = new SavvyTasker();
        loadSavvyTaskerWithSampleData(st);
        return st;
    }
    
    private Date getDate(String ddmmyyyy) {
        try {
            return format.parse(ddmmyyyy);
        } catch (Exception e) {
            assert false; //should not get an invalid date....
        }
        return null;
    }
}
```
###### \java\seedu\savvytasker\testutil\TypicalTestTasks.java
``` java

```
